https://ko.react.dev/blog/2024/12/05/react-19

# 액션

개발하다가 흔히 나오는 케이스 : 데이터 변경 → 응답에 따라 상태 변경

## 기존

대기, 에러, 낙관적 업데이트, 순차적 요청 수동처리

```tsx
// 액션 이전
function UpdateName({}) {
  const [name, setName] = useState("");
  const [error, setError] = useState(null);
  const [isPending, setIsPending] = useState(false);

  const handleSubmit = async () => {
    setIsPending(true);
    const error = await updateName(name);
    setIsPending(false);
    if (error) {
      setError(error);
      return;
    }
    redirect("/path");
  };

  return (
    <div>
      <input value={name} onChange={(event) => setName(event.target.value)} />
      <button onClick={handleSubmit} disabled={isPending}>
        Update
      </button>
      {error && <p>{error}</p>}
    </div>
  );
}
```

## React 19

- `useTransition` 덕에 데이터가 변경되는 동안에도 UI 반응성 & 상호작용성 유지 가능
- 낙관적 업데이트를 관리하는 `useOptimistic` 훅 + 일반적인 케이스를 처리하는 `useActionState` 훅 추가.
- react-dom에서는 `form` 액션과 폼 내의 공통 케이스를 지원하는 `useFormStatus` 추가

```tsx
// `<form>` 액션과 `useActionState`의 사용
function ChangeName({ name, setName }) {
  const [error, submitAction, isPending] = useActionState(
    async (previousState, formData) => {
      const error = await updateName(formData.get("name"));
      if (error) {
        return error;
      }
      redirect("/path");
      return null;
    },
    null,
  );

  return (
    <form action={submitAction}>
      <input type="text" name="name" />
      <button type="submit" disabled={isPending}>Update</button>
      {error && <p>{error}</p>}
    </form>
  );
}
```

### `useActionState`

- 함수를 받아서 이를 호출하는 래핑된 액션을 반환
- 래핑된 액션이 호출되면 액션의 마지막 결과를 반환배열의 첫번째 요소로, 액션의 대기 상태를 세번째 요소로 반환
- Canary에서는 `useFormState`였지만 19버전에서 `useActionState`로 이름 정해짐

### **`<form>` 액션**

- `form`, `input`, `button` 엘리먼트의 `action`과 `formAction` 속성에 함수를 전달하여 액션으로 폼을 자동으로 제출할 수 있게됨
- `form` 액션이 성공하면 비제어 컴포넌트의 경우 폼을 자동으로 재설정함. 수동으로 `form`을 재설정해야하는 경우, 새로운 React DOM API인 `requestFormReset` 호출가능

### **`useFormStatus`**

- `form`이 ContextProvider인 것 처럼 부모 `form`의 상태를 읽을 수 있음
    
    ```tsx
    import {useFormStatus} from 'react-dom';
    
    function DesignButton() {
      const {pending} = useFormStatus();
      return <button type="submit" disabled={pending} />
    }
    ```
    

### **`useOptimistic`**

- 낙관적 업데이트를 더 쉽게 하기 위한 훅
    
    ```tsx
    function ChangeName({currentName, onUpdateName}) {
      const [optimisticName, setOptimisticName] = useOptimistic(currentName);
    
      const submitAction = async formData => {
        const newName = formData.get("name");
        setOptimisticName(newName);
        const updatedName = await updateName(newName);
        onUpdateName(updatedName);
      };
    
      return (
        <form action={submitAction}>
          <p>Your name is: {optimisticName}</p>
          <p>
            <label>Change Name:</label>
            <input
              type="text"
              name="name"
              disabled={currentName !== optimisticName}
            />
          </p>
        </form>
      );
    }
    ```
    
    - `updateName` 요청이 진행중일 때 `optimisticName`을 즉시 렌더링함
        - 업데이트가 끝나거나 에러가 발생했을때 값은 이전값으로 돌아감

### `use`

- Resource를 읽기 위한 새로운 API
- Promise를 받아서, Promise가 resolve 때까지 Suspend 됨
    
    ```tsx
    import {use} from 'react';
    
    function Comments({commentsPromise}) {
      // `use`는 promise가 처리될 때까지 중단될 것입니다.
      const comments = use(commentsPromise);
      return comments.map(comment => <p key={comment.id}>{comment}</p>);
    }
    
    function Page({commentsPromise}) {
      // Comments 컴포넌트에서 `use`가 중단될 때
      // Suspense Boundary가 보일 것 입니다.
      return (
        <Suspense fallback={<div>Loading...</div>}>
          <Comments commentsPromise={commentsPromise} />
        </Suspense>
      )
    }
    ```
    
- 렌더 함수에서 생성한 Promise는 지원하지 않음
- Context를 불러올 때 사용할 수도 있음
    
    ```tsx
    import {use} from 'react';
    import ThemeContext from './ThemeContext'
    
    function Heading({children}) {
      if (children == null) {
        return null;
      }
      
      // This would not work with useContext
      // because of the early return.
      const theme = use(ThemeContext);
      return (
        <h1 style={{color: theme.color}}>
          {children}
        </h1>
      );
    }
    ```
    
- 훅처럼 렌더 함수 내에서만 호출 할 수 있음. 하지만, 훅과는 다르게 조건부로 호출될 수 있음

# 새로운 React DOM Static API들

`react-dom/static` API가 두개 추가됨

- `prerender`
- `prerenderToNodeStream`

위 두 API를 통해서 `renderToString` 의 확장형으로, 정적인 HTML 생성을 위해서 데이터가 로드될때까지 기다린다. Node.js 스트림이나 웹 스트림 같은 환경에서 동작하도록 설계되었다.

Prerender API들은 정적인 HTML 스트림을 반환하기 전에 모든 데이터가 로드될때까지 기다린다. 스트림은 문자열로 변환되거나 스트리밍 응답으로 보내질 수 있다. 로딩중에 스트리밍은 지원하지 않는다(React DOM Server Rendering API에서 지원)

# RSC(React Server Components)

## Server Components

서버 컴포넌트는 클라이언트/SSR 서버가 아닌 번들링 전 단계에서 컴포넌트를 미리 렌더링할 수 있는 옵션이다. 서버 컴포넌트는 CI 서버에서 빌드타임에 실행될 수도 있고, 런타임에 웹서버에서 각 요청에 대응하여 실행될 수도 있다.

## Server Actions

서버 액션은 클라이언트 컴포넌트들이 서버에서 실행되는 비동기 함수를 호출할 수 있게 해준다.

서버액션이 `use server` 디렉티브로 정의되어 있다면, 당신이 사용하는 프레임워크가 알아서 서버 함수의 레퍼런스를 만들고, 클라이언트 컴포넌트에게 넘겨줄 것이다. 해당 함수가 클라이언트에서 호출되면, 리액트가 서버에 해당 함수를 호출하도록 요청을 보내고, 결과를 받아온다.

서버 액션은 서버 컴포넌트에서 생성되어 클라이언트 컴포넌트로 넘겨지거나, 클라이언트 컴포넌트에서 import 하여 사용할 수도 있다.

# Improvements in React 19

## `ref` as prop

이제 `ref`를 함수형 컴포넌트의 prop으로 접근할 수 있다.

```tsx
function MyInput({placeholder, ref}) {
  return <input placeholder={placeholder} ref={ref} />
}

//...
<MyInput ref={ref} />
```

새로운 함수형 컴포넌트들은 더이상 `forwarRef`를 필요로 하지 않을 것이고, 따라서 이후에는 `forwardRef`를 deprecate하고 제거할 예정이다.

## 하이드레이션 에러 Diff

`react-dom`의 하이드레이션 에러 리포팅 기능을 개선했다. 여러개의 중복 mismatch 에러 정보를 남기는 것 대신, 하나의 명확한 메세지를 남기는 것으로 개선됐다.

## `<Context>` as Provider

`<Context.Provider>` 대신 `<Context>`를 프로바이더로 쓸 수 있게 됐다.

```tsx
const ThemeContext = createContext('');

function App({children}) {
  return (
    <ThemeContext value="dark">
      {children}
    </ThemeContext>
  );  
}
```

추후 `Context.Provider`는 deprecate 되고 제거 될 예정이다.

## ref 클린업 함수

`ref` 콜백에서 클린업 함수를 반환하는 것을 지원한다.

```tsx
<input
  ref={(ref) => {
    // ref created

    // NEW: return a cleanup function to reset
    // the ref when element is removed from DOM.
    return () => {
      // ref cleanup
    };
  }}
/>
```

컴포넌트가 언마운트 될 때, 리액트는 `ref` 콜백이 반환한 클린업 함수를 호출한다. 이는 DOM refs, 클래스 컴포넌트 refs, `useImperativeHandle`의 경우에 동작한다.

- 이전에는 컴포넌트 언마운트 시에 `ref` 함수를 `null` 인자와 함께 호출했었다. 이제 `ref` 함수가 클린업 함수를 반환하면, `null`과 함께 호출되는 동작은 없을 것이다.
- 추후 컴포넌트 언마운트시 `null`과 함께 호출되는 동작은 deprecate될 예정이다.

클린업 함수의 등장으로 인해, 더이상 `ref` 함수에서 함수 이외의 것을 반환할 경우 타입스크립트 에러가 날 것이다. 암시적 반환문을 제거하면 대부분 해결되는 문제다.

## `useDeferredValue` 초기값

`useDeferredValue`에 `initialValue` 옵션이 추가되었다.

```tsx
function Search({deferredValue}) {
  // On initial render the value is ''.
  // Then a re-render is scheduled with the deferredValue.
  const value = useDeferredValue(deferredValue, '');
  
  return (
    <Results query={value} />
  );
}
```

`initialValue`가 주어진 경우, 컴포넌트의 첫번째 렌더에서는 `initialValue`를 반환하고, 백그라운드에서 `deferredValue` 값으로 리렌더링을 스케줄한다.

## Document Metadata 지원

HTML에서 `<title>`, `<link>`, `<meta>` 등 태그들은 Document의 `<head>` 섹션에 위치하도록 되어있다. 

리액트에서는, 어떤 메타데이터를 세팅해야할지 판단하는 컴포넌트는 `<head>`에서 굉장히 멀 가능성이 높거나, React가 아예 `<head>`를 렌더링하지 않을 수 있다. 

이전에는 이러한 요소들을 `useEffect` 구문등을 통해서 직접 넣어주거나 `react-helmet` 같은 라이브러리를 사용해서 넣어줬다. 그리고 이는 SSR을 할 때 조심스럽게 다뤄야하는 문제였다.

React 19에서는 컴포넌트에서 Document 메타데이터 태그들을 네이티브하게 렌더링하는 것을 지원한다.

```tsx
function BlogPost({post}) {
  return (
    <article>
      <h1>{post.title}</h1>
      <title>{post.title}</title>
      <meta name="author" content="Josh" />
      <link rel="author" href="https://twitter.com/joshcstory/" />
      <meta name="keywords" content={post.keywords} />
      <p>
        Eee equals em-see-squared...
      </p>
    </article>
  );
}
```

리액트가 이 컴포넌틀 렌더링 할 때, 메타데이터 태그들을 보고 자동으로 Document의 `head` 섹션으로 해당 태그들을 “호이스팅”해준다. 이는 Client Only 앱, Streaming SSR, 서버 컴포넌트 모두에서 동작한다.

## 스타일시트 지원

리액트에게 각 스타일시트의 `precedence`를 알려주면, 리액트가 스타일시트의 삽입 순서를 잘 조정하여 삽입하고, 해당 스타일시트에 의존하고 있는 콘텐츠를 렌더링하기 전에 로드됨을 보장해준다.

```tsx
function ComponentOne() {
  return (
    <Suspense fallback="loading...">
      <link rel="stylesheet" href="foo" precedence="default" />
      <link rel="stylesheet" href="bar" precedence="high" />
      <article class="foo-class bar-class">
        {...}
      </article>
    </Suspense>
  )
}

function ComponentTwo() {
  return (
    <div>
      <p>{...}</p>
      <link rel="stylesheet" href="baz" precedence="default" />  <-- will be inserted between foo & bar
    </div>
  )
}
```

SSR 중에는 리액트가 스타일시트들을 `head`에 넣어줘서 브라우저가 스타일시트 로딩 전에는 paint를 하지 않도록 막아준다. 만약 스타일시트가 스트리밍 도중에 발견되었다면, 리액트가 해당 스타일시트가 클라이언트의 `head`에 추가하여 해당 스타일시트가 로딩되기 전에는 Suspense 바운더리가 fallback을 보여주게된다.

CSR 중에는 새롭게 렌더링된 스타일시트가 로딩될때까지 렌더를 커밋하지 않는다. 만약 동일한 스타일시트를 여러 컴포넌트에서 로드 시도하는 경우, 리액트가 Document에서 한번만 로드되도록 막아준다.

```tsx
function App() {
  return <>
    <ComponentOne />
    ...
    <ComponentOne /> // won't lead to a duplicate stylesheet link in the DOM
  </>
}
```

즉, 이제 더이상 스타일시트를 실제 사용처에서 멀리 떨어진 채로 로드할 필요 없이, 해당 스타일시트를 필요로하는 컴포넌트에 가까이 두어 응집도를 높일 수 있게 되었다.

## async script 지원

async script를 컴포넌트 트리 어디에서나 렌더링할 수 있게 되었다. 해당 스크립트를 필요로 하는 컴포넌트 가까이에 스크립트를 두어, 응집도를 높일 수 있게 되었다. 이 역시 deduping처리되어 하나의 스크립트를 중복으로 로드해오는 경우는 없을 것이다.

```tsx
function MyComponent() {
  return (
    <div>
      <script async={true} src="..." />
      Hello World
    </div>
  )
}

function App() {
  <html>
    <body>
      <MyComponent>
      ...
      <MyComponent> // won't lead to duplicate script in the DOM
    </body>
  </html>
}

```

SSR에서는 async script들이 `head`로 보내져 더 중요한 resource들(스타일시트, 폰트, 이미지 preload) 뒤에 로드되도록 배치된다.

## preloading resource 지원

최초 Document 로드와 클라이언트 사이드 업데이트 중에, 브라우저에게 어떤 리소스를 가능한 빠르게 로드해야하는지 알려줄 수 있다면 페이지 성능을 크게 향상시킬 수 있을 것이다.

React 19에서는 신규API들을 통해서 브라우저 리소스 로딩/프리로딩을 쉽게 만들고, 효율적으로 리소르를 로드해오게 할 수 있다.

```tsx
import { prefetchDNS, preconnect, preload, preinit } from 'react-dom'
function MyComponent() {
  preinit('https://.../path/to/some/script.js', {as: 'script' }) // loads and executes this script eagerly
  preload('https://.../path/to/font.woff', { as: 'font' }) // preloads this font
  preload('https://.../path/to/stylesheet.css', { as: 'style' }) // preloads this stylesheet
  prefetchDNS('https://...') // when you may not actually request anything from this host
  preconnect('https://...') // when you will request something but aren't sure what
}
```

```tsx
<!-- the above would result in the following DOM/HTML -->
<html>
  <head>
    <!-- links/scripts are prioritized by their utility to early loading, not call order -->
    <link rel="prefetch-dns" href="https://...">
    <link rel="preconnect" href="https://...">
    <link rel="preload" as="font" href="https://.../path/to/font.woff">
    <link rel="preload" as="style" href="https://.../path/to/stylesheet.css">
    <script async="" src="https://.../path/to/some/script.js"></script>
  </head>
  <body>
    ...
  </body>
</html>
```

새롭게 추가된 API들을 통해서 최초 페이지 로드 성능을 최적화할 수 있다. 추가적인 리소스의 로드 속도를 조정한다던지, 가까운 미래에 발생할 네비게이션에 따른 리소스 프리페칭을 통해서 클라이언트 측 화면 업데이트 성능에도 긍정적 영향을 끼칠 수 있다.

## 써드파티 스크립트 / 익스텐션과의 호환성

하이드레이션 과정에서 mismatch가 발견되면 React가 클라이언트 리렌더링을 강제하여 콘텐츠를 “고친다”. 이전에는 써드파티 스크립트나 브라우저 익스텐션에 의해 추가된 요소들이 mismatch를 유발했고 이로인해 리렌더링이 발생했다.

이제 예상되지 않은 `head`와 `body` 내의 태그들은 무시되며, mismatch 에러를 발생시키지 않는다. 그리고 만약 리액트가 관련없는 하이드레이션 미스매치로 인해 리렌더링을 하는 경우, 써드파티/익스텐션이 추가한 스타일시트는 그대로 둔다.

## 더 나은 에러 리포팅

중복 에러 제거를 위해 몇가지 개선이 있었다.

- 에러 바운더리에서 에러 발생시 두번 에러가 찍힘 → 한번에 모아서 찍히도록 바꿈
- 루트에서 `onRecoverableError`를 보완하기 위해 옵션 추가
    - `onCaughtError` : 리액트가 에러 바운더리에서 에러를 잡았을 때 호출
    - `onUncaughtError` : 에러가 던져졌고 에러 바운더리에서 에러를 잡지 못했을 때 호출
    - `onRecoverableError` : 에러가 던져졌고 자동으로 회복됐을 때 호출

## Custom Element 지원

React 19에서 Custom Element가 완전히 지원되며, 모든 테스트가 통과되었음.

이전 버전에서는 Custom Element를 리액트에서 쓰는 것이 어려웠음(리액트 컴포넌트가 알 수 없는 props들을 속성으로 취급했기 때문에)

React 19에서는 클라이언트/SSR 양쪽에서 모두 동작하는 속성을 지원함

- SSR에서
    - Custom Element에 전달된 props는 그 타입이 `string`이나 `number`, `true` 중 하나라면 속성으로 렌더링되고, `object`, `symbol`, `function`와 같은 non-primitive 타입이나 `false` 값인 경우 생략된다.
- CSR에서
    - Custom Element의 프로퍼티로 매칭된 props의 경우 property로 지정되고, 아니라면 속성으로 지정된다.