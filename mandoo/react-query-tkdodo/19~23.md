## 타입 안정성 챙기기

네트워크 요청을 통해서 오는 데이터를 정확히 알 길이 없기 때문에, 아래와 같이 제네릭 타입을 넘겨서 직접 타입을 지정해주고 한다.

```tsx
const fetchTodo = async (id: number) => {
  const response = await axios.get<Todo>(`/todos/${id}`)
  return response.data
}
```

하지만 이는 제네릭의 황금 규칙을 위반하는 꼴이다. 제네릭의 황금 규칙은 아래와 같다.

> 제네릭이 유용하려면, 그것이 적어도 두번 등장해야한다.
> 

소위 “return only” 제네릭은 타입 단언과 다를 것이 없다. `axios.get`의 타입 시그니처를 보면..

```tsx
function get<T = any>(url: string): Promise<{ data: T, status: number}>
```

`T` 제네릭 타입이 반환타입 한 곳에서만 등장한다. 따라서 이는 거짓말이다. 아래 코드와 다를바가 없다.

```tsx
const fetchTodo = async (id: number) => {
  const response = await axios.get(`/todos/${id}`)
  return response.data as Todo
}
```

최소한 타입 단언으로 코드를 작성하면 명시적이고 숨겨져있지 않다. 컴파일러를 거스르고 안전하지 않은 것을 억지로 우리가 믿을 수 있는 타입으로 변경하고 있음을 확실히 알린다.

### 그래서 어떻게 하나요

어떻게 하면 데이터가 특정 타입이라는 것을 믿을 수 있을까? 사실 불가능할지도 모르고, 그것대로 괜찮을지도 모른다.

이러한 상황을 “trusted boundary” 라고 부른다. 우리의 백엔드가 약속한대로 데이터를 내려줄 것이라고 믿는 것이다. **만약 그렇지 않다면, 그건 우리 잘못이 아니다. 백엔드 팀의 잘못이다.**

하지만 고객은 여기에 대해 신경쓰지 않는다. 그들이 보는 것은 `cannot read property name of undefined` 같은 메세지이고, 프론트엔드 팀이 소환당할 것이고 어떤 것이 잘못되었는지 알아내는 데 시간을 쓸 것이고 백엔드에서 데이터를 약속한대로 주지 않고 있다는 것을 알아내게 될 것이다.

그렇다면 우리에게 믿음을 줄 수 있는 것은 무엇이 있을까?

### Schema Validation

Zod를 이용해서 `queryFn` 단에서 파싱을 하는 방법이 있다.

```tsx
import { z } from 'zod'

// 👀 define the schema
const todoSchema = z.object({
  id: z.number(),
  name: z.string(),
  done: z.boolean(),
})

const fetchTodo = async (id: number) => {
  const response = await axios.get(`/todos/${id}`)
  // 🎉 parse against the schema
  return todoSchema.parse(response.data)
}

const query = useQuery({
  queryKey: ['todos', id],
  queryFn: () => fetchTodo(id),
})
```

이렇게 하면 기대하지 않은 형태로 데이터가 왔을때 에러 상태가 되며, 사용자는 에러 상태에 해당하는 UI를 보게될 것이다.

하지만 여기에는 Tradeoff가 있다. 스키마가 잘못됐다면 제대로 된 상황에서도 에러 상태를 볼 가능성도 있고, 런타임에 파싱을 해야하기 때문에 그만큼 성능 오버헤드가 발생하기도 한다. 따라서 모든 상황에 validation layer를 넣는 것은 적절하지 않을 수 있다.

## 컨텍스트 + 리액트 쿼리

특정 쿼리를 선언해놓고 컴포넌트 트리 상단에서 loading/error 상태에 대한 처리를 해두고, 하단에서는 특정 필드만 쓰고 싶을 때가 많다.

이럴때 각 컴포넌트가 같은 쿼리를 호출하게 해서 해결하는 경우가 많다. 예를들어 컴포넌트 하단에 아래와 같은 컴포넌트가 있다고 치면..

```tsx
function UserNameDisplay() {
  const { data } = useCurrentUserQuery()
  return <div>User: {data.userName}</div>
}
```

당연히 컴포넌트 트리 상단에서 로딩/에러 체크를 하고 있다는 것을 코드를 작성하는 개발자 입장에서는 알고 있으니 이렇게 작성하고 싶을 수 있다. 하지만 다른 동료들이 봤을때, 3개월 뒤의 내가 봤을때도 그럴까? 그렇지 않다. 이러한 암묵적 의존성이 있는 것은 좋지않다.

따라서 이 의존성을 명시적으로 만들어줘야한다.

이 과정에서 리액트 컨텍스트를 의존성 주입 용도로 사용해주면 좋다. Props Drilling은 피하고, loading/error 상태 처리는 컴포넌트 트리 상단에서 할 수 있다.

```tsx
const CurrentUserContext = React.createContext<User | null>(null)

export const useCurrentUserContext = () => {
  const currentUser = React.useContext(CurrentUserContext)
  if (!currentUser) {
    throw new Error('CurrentUserContext: No value provided')
  }

  return currentUser
}

export const CurrentUserContextProvider = ({
  children,
}: {
  children: React.ReactNode
}) => {
  const currentUserQuery = useCurrentUserQuery()

  if (currentUserQuery.isPending) {
    return <SkeletonLoader />
  }

  if (currentUserQuery.isError) {
    return <ErrorMessage error={currentUserQuery.error} />
  }

  return (
    <CurrentUserContext.Provider value={currentUserQuery.data}>
      {children}
    </CurrentUserContext.Provider>
  )
}
```

이렇게 세팅해주면 single source of truth는 여전히 쿼리가 뱉는 데이터이고, 컨텍스트에 들어간 값이 최신 쿼리값과 달라지는 일이 없게된다.

## React Query를 사용하지 않아도 되지않나?

그냥 `useEffect` + `useState`를 사용해서 간단하게 데이터 페칭을 해도 되지 않냐는 의문이 생길 수 있다. 아래와 같은 코드로 시작을 하게될텐데, 여기에는 몇가지 문제가 있다.

```tsx
function Bookmarks({ category }) {
  const [data, setData] = useState([])
  const [error, setError] = useState()

  useEffect(() => {
    fetch(`${endpoint}/${category}`)
      .then(res => res.json())
      .then(d => setData(d))
      .catch(e => setError(e))
  }, [category])

  // Return JSX based on data and error state
}
```

1. Race Condition
    1. `category`가 변경될때 race condition이 발생할 수 있다. 먼저 간 네트워크 요청의 응답이 먼저 온다는 보장이 없기 때문에, 사용자가 잘못된 데이터를 볼 가능성이 생긴다.
2. 로딩 상태
    1. 로딩 상태를 보여줄만한 추가 플래그 값이 필요하다
3. Empty State
    1. 데이터가 도착하지 않은 상태와 데이터를 받아왔지만 비어있는 상태를 구분할 수 있어야한다.
4. `category` 값이 변경될 때 Data/Erorr 상태 초기화가 필요하다
5. `StrictMode`에서 두번 호출됨

이렇듯 **데이터페칭은 어렵지 않지만, 비동기 상태 관리가 어렵다**. 이런 문제를 리액트 쿼리가 훅 호출 한번으로 해결해주니, 충분히 사용할만한 가치가 있는 것이다. 리액트 쿼리를 사용하면 위 문제를 다 해결해준다.

```tsx
function Bookmarks({ category }) {
  const { isLoading, data, error } = useQuery({
    queryKey: ['bookmarks', category],
    queryFn: () =>
      fetch(`${endpoint}/${category}`).then((res) => {
        if (!res.ok) {
          throw new Error('Failed to fetch')
        }
        return res.json()
      }),
  })

  // Return JSX based on data and error state
}
```

## AbortSignal로 불필요한 요청 취소하기

쿼리 컨텍스트에서 받아온 `signal`을 사용해서 철지난 요청은 취소하도록 설정할 수 있다.

```tsx
function Bookmarks({ category }) {
  const { isLoading, data, error } = useQuery({
    queryKey: ['bookmarks', category],
    queryFn: ({ signal }) =>
      fetch(`${endpoint}/${category}`, { signal }).then((res) => {
        if (!res.ok) {
          throw new Error('Failed to fetch')
        }
        return res.json()
      }),
  })

  // Return JSX based on data and error state
}
```
