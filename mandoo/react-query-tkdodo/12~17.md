## Awaiting mutation callback

mutation callback이 반환하는 Promise는 리액트 쿼리에 의해 await 될 수 있다. `invalidateQueries`도 Promise를 반환해주는데, 만약 원하는 쿼리들이 invalidate 될 때까지 기다리고 싶다면 `invalidateQueries`가 반환하는 값을 await해주면 된다.

```tsx
{
  // 🎉 will wait for query invalidation to finish
  onSuccess: () => {
    return queryClient.invalidateQueries({
      queryKey: ['posts', id, 'comments'],
    })
  }
}
{
  // 🚀 fire and forget - will not wait
  onSuccess: () => {
    queryClient.invalidateQueries({
      queryKey: ['posts', id, 'comments']
    })
  }
}
```

## mutate VS mutateAsync

- `mutate`는 아무것도 반환하지 않고, `mutateAsync`는 mutation의 결과를 담은 Promise를 반환해준다
- `mutate`를 사용한다면 unhandled promise rejection에 대한 걱정은 안해도 된다. `mutateAsync`의 경우 에러 케이스를 직접 핸들링해줘야한다.
- 대부분 케이스에 `mutate`를 쓰는 것이 바람직하다. 성공/실패에 따른 처리는 callback을 사용하면된다

## mutate 콜백은 호출되지 않을수도 있다

순서상 `useMutation`에 넘긴 콜백들 호출 → `mutate`에 넘긴 콜백들 호출 순서로 실행된다. 하지만 `mutate`에 넘긴 콜백들은 **mutation이 끝나기전에 컴포넌트가 언마운트된다면 아예 호출되지 않을 수도 있다**.

따라서, 아래와 같이 콜백을 나누느 것이 권장된다.

- 꼭 실행되어야하는 로직 → `useMutation` 콜백으로 넘긴다
    - query invalidation 등
- UI와 관련된 로직 → `mutate` 콜백으로 넘긴다
    - 리다이렉션, 토스트 알림 등, mutation이 끝나기전에 사용자가 화면을 떠난다면 자연스럽게 이 UI 로직들은 실행되지 않을 것이다.

## 오프라인 상황에서의 리액트 쿼리

v4부터 `networkMode` 옵션이 생겨서 쿼리별로 네트워크 상황이 여의치않을때 어떻게 동작하게 할지 지정해줄 수 있다.

- `online`
    - 네트워크 연결이 활성화된 경우에만 쿼리를 실행
    - 네트워크 연결이 없는 상황에서 쿼리 실행시, `fetchStatus`가 `paused`가 됨 (`loading/success/error` 상태와 별도)
- `always`
    - 네트워크 상황 신경안쓰고 그냥 무조건 쿼리 실행
    - 네트워크를 필요로 하지 않는 `queryFn` 사용시 적절
- `offlineFirst`
    - 첫번째 요청은 무조건 하고, 실패하면 재시도는 일시정지함
    - 브라우저 캐시 / 별도 캐싱 레이어가 있는 경우 유용

추가적으로 `fetchStatus` 상태 값에 대한 다양한 케이스를 고려해서 더 “탄탄한” 앱을 만들 수 있다.

- `fetching`
    - 쿼리가 실행중이고, 요청을 보낸상태다
- `paused`
    - 쿼리가 실행중이지 않고, 연결을 다시 획득할때까지 일시정지된 상태다
- `idle`
    - 쿼리가 현재 동작하지 않고 있다.

## 로딩상태 활용하기 - keepPreviousData

`placeholderData: keepPreviousData`를 활용하면, 쿼리키 변경을 통해 데이터 페칭이 발생할때 쿼리키가 바뀌기 이전 데이터를 `placeholderData`로 쓸 수 있다.

```tsx
import { keepPreviousData } from '@tanstack/react-query'

const { data, isPlaceholderData } = useQuery({
  queryKey: ['item', id],
  queryFn: () => fetchItem({ id }),
  // ⬇️ like this️
  placeholderData: keepPreviousData,
})
```

여기에 `isPlaceolderData` 플래그까지 활용해서 적절한 UI를 보여주면 스무스한 화면전환을 만들 수 있다.

## Suspense Waterfall

`useQuery`를 사용할때는 Waterfall 현상이 일어나지 않기 때문에, 한 컴포넌트 내에서 `useQuery`를 여러번해도 문제가 없다.

```tsx
// 1. Use useQuery twice
const issues = useQuery({ queryKey: ['issues'], queryFn: fetchIssues })
const labels = useQuery({ queryKey: ['labels'], queryFn: fetchLabels })

// 2. Use the useQueries hook
const [issues, labels] = useQueries([
  { queryKey: ['issues'], queryFn: fetchIssues },
  { queryKey: ['labels'], queryFn: fetchLabels },
])
```

![](https://velog.velcdn.com/images/mskwon/post/4336fd5c-fe5a-425c-9202-64e5ea500871/image.png)

하지만 `useSuspenseQuery`의 경우, 컴포넌트 렌더링 시에 첫번째로 사용된 `useSuspenseQuery`가 Promise를 던지기에 waterfall 현상이 발생한다. 

![](https://velog.velcdn.com/images/mskwon/post/164ab71a-5220-4529-aa56-16dac981e767/image.png)


과정을 자세히 정리하면 아래와 같다.

- 컴포넌트 렌더 → 첫번째 쿼리 읽기 시도
- 캐시에 데이터가 없음 → suspend 됨
- 컴포넌트가 언마운트 되고, fallback이 렌더링 됨
- fetch 완료, 컴포넌트 트리가 remount됨
- 첫번째 쿼리 데이터를 캐시로부터 읽ㅇ어옴
- 두번째 쿼리 발견, 읽기 시도
- 캐시에 데이터가 없음 → suspend 됨
- 두번째 쿼리가 페칭됨
- 컴포넌트가 성공적으로 렌더링 됨

따라서 병렬로 페칭이 발생하지 못하고, 로딩 시간이 더 오래 걸리는 것처럼 느껴질 수 있다. 이를 회피하는 가장 좋은 방법은 컴포넌트 하나에 쿼리 하나를 쓰거나 캐시에 항상 데이터가 있도록 하는 것이지만, 현실적으로 그러기 쉽지 않다.

v5 이전에는 prefetching 전략 등을 통해서 이를 해결해야 했지만, v5에 [`useSuspenseQueries`](https://tanstack.com/query/latest/docs/framework/react/reference/useSuspenseQueries)가 등장해 이를 해결할 수 있게 됐다.