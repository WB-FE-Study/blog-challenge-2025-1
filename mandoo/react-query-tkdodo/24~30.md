## QueryOptions API와 타입스크립트

타입스크립트의 특성상, 인라인으로 없는 필드를 넣으면 오류를 뱉지만

```tsx
useQuery({
  queryKey: ['todos'],
  queryFn: fetchTodos,
  stallTime: 5000,
})
```

> **Object literal may only specify known properties, but 'stallTime' does not exist in type 'UseQueryOptions<Todo[], Error, Todo[], string[]>'. Did you mean to write 'staleTime'?(2769)**
> 

인라인이 아닌 별도 객체로 선언해서 넘기면 에러가 안난다

```tsx
const todosQuery = {
  queryKey: ['todos'],
  queryFn: fetchTodos,
  stallTime: 5000,
}

useQuery(todosQuery)
```

이 경우 오타 하나로 동작이 의도한대로 하지 않을 수 있고, 원인을 찾기가 어렵다. 그래서 `queryOptions` 헬퍼 함수가 제공된다. 요 함수를 사용해서 `useQuery`에 실제로 사용하기 전에 type-safe한 쿼리 옵션 객체를 만들 수 있다.

```tsx
export function queryOptions(options) {
  return options
}
```

기존의 `getQueryData` 메서드는 반환 타입이 `unknown`이라서 사용할때 사실상 타입단언을 하고 사용해야했다. 따라서 type-safe하다고 할 수 없었다.

```tsx
const todos = queryClient.getQueryData<Array<Todo>>(['todos'])
//    ^? const todos: Todo[] | undefined
```

하지만 `queryOptions` 함수를 여기서 활용해주면 반환값에 queryOptions에 선언한 값에 맞는 반환 타입이 들어가게된다.

```tsx
const todosQuery = queryOptions({
  queryKey: ['todos'],
  queryFn: fetchTodos,
  staleTime: 5000,
})

const todos = queryClient.getQueryData(todosQuery.queryKey)
//    ^? const todos: Todo[] | undefined
```

이게 가능한 이유는, queryOptions의 쿼리키에 **data tag Symbol**이 숨어있기 때문이다!

```tsx
(property) queryKey: string[] & {
  [dataTagSymbol]: Todo[];
}
```

이 타입을 이용해서 `getQueryData`, `setQueryData` 등 메서드들이 적절한 타입을 유추할 수 있다.

## Global MutationCache Callbacks

개별 `Mutation`에서 `onSuccess`, `onError`, `onSettled` 콜백을 넘길 수 있듯이,  `MutationCache`에도 이 콜백들을 넘길 수 있다. 이 콜백들은 전역에 영향을 주며, 모든 뮤테이션에 대해서 호출되게된다.

```tsx
import { QueryClient, MutationCache } from '@tanstack/react-query'

const queryClient = new QueryClient({
  mutationCache: new MutationCache({
    onSuccess,
    onError,
    onSettled,
  }),
})
```

반환된 Promise는 마찬가지로 await 될 것이며, 마지막 파라미터로 Mutation 인스턴스를 추가로 받게된다.

이 전역 콜백을 아래와 같이 활용하면, mutation 뒤에 모든 쿼리를 invalidate 처리할 수 있다.

```tsx
const queryClient = new QueryClient({
  mutationCache: new MutationCache({
    onSuccess: () => {
      queryClient.invalidateQueries()
    },
  }),
})
```

### 너무 과하지 않나요?

그럴수도 있고 아닐수도 있다. 여기서 명심해야될 것은, invalidation이 항상 refetch로 바로 이어지지는 않는다는 것이다. invalidation은 모든 active한 쿼리캐시들에 대한 refetch를 수행한다. 나머지에 대해서는 `stale` 처리만 해버리고, 다음에 사용될때 refetch 될 수 있도록 한다.

즉, 모든 것을 invalidate 한다고 해도 사용자가 화면에 보고 있는 데이터들에 대해서만 refetch가 수행된다는 뜻이다.

## Invalidation과 특정 쿼리 묶기

### 쿼리키와 `mutationKey` 묶기

개별 Mutation에 엮고자 하는 쿼리키와 동일한 mutation key를 집어넣고, 전역 콜백에서 아래와 같이 세팅해주면 매칭하는 쿼리키들이 invalidate된다.

```tsx
const queryClient = new QueryClient({
  mutationCache: new MutationCache({
    onSuccess: (_data, _variables, _context, mutation) => {
      queryClient.invalidateQueries({
        queryKey: mutation.options.mutationKey,
      })
    },
  }),
})
```

그리고 이 경우 `mutationKey`가 선언되지 않은 뮤테이션이 발생한 경우, 모든 쿼리키가 invalidate된다.

### `staleTime`에 따라서 특정 쿼리들은 제외시키기

전역 콜백에서 특정 `staleTime` 이하인 쿼리들만 invalidate 시키는 것도 가능하다.

```tsx
const queryClient = new QueryClient({
  mutationCache: new MutationCache({
    onSuccess: (_data, _variables, _context, mutation) => {
      const nonStaticQueries = (query: Query) => {
        const defaultStaleTime =
          queryClient.getQueryDefaults(query.queryKey).staleTime ?? 0
        const staleTimes = query.observers
          .map((observer) => observer.options.staleTime)
          .filter((staleTime) => staleTime !== undefined)

        const staleTime =
          query.getObserversCount() > 0
            ? Math.min(...staleTimes)
            : defaultStaleTime

        return staleTime !== Number.POSITIVE_INFINITY
      }

      queryClient.invalidateQueries({
        queryKey: mutation.options.mutationKey,
        predicate: nonStaticQueries,
      })
    },
  }),
})
```

### `meta` 옵션 사용하기

Mutation에 대한 정적인 정보들을 `meta` 옵션을 통해서 선언할 수 있다. 예를들어, `invalidates` 필드에 뮤테이션에 태깅을 할 수 있다. 그리고 이 태그들을 이용해서 적절한 쿼리키들을 invalidate 할 수 있다.

```tsx
import { matchQuery } from '@tanstack/react-query'

const queryClient = new QueryClient({
  mutationCache: new MutationCache({
    onSuccess: (_data, _variables, _context, mutation) => {
      queryClient.invalidateQueries({
        predicate: (query) =>
          // invalidate all matching tags at once
          // or everything if no meta is provided
          mutation.meta?.invalidates?.some((queryKey) =>
            matchQuery({ queryKey }, query)
          ) ?? true,
      })
    },
  }),
})

// usage:
useMutation({
  mutationFn: updateLabel,
  meta: {
    invalidates: [['issues'], ['labels']],
  },
})
```

이 방법은 `useMutation` 단에서 콜백을 선언하는 것과 크게 다르지 않지만, 적어도 각 mutation 훅에서 `useQueryClient`를 호출할 필요는 없어진다.

그리고 모든것을 invalidate하도록 설정해놓은 환경에서, 몇몇 쿼리는 opt out하도록 설정하도록 도움을 준다.

`meta` 옵션에 대한 타이핑은 module augmentation을 통해서 할 수 있다.

```tsx
declare module '@tanstack/react-query' {
  interface Register {
    mutationMeta: {
      invalidates?: Array<QueryKey>
    }
  }
}
```

### 기다릴 것인가 말 것인가

`meta`에 필드 하나를 추가해서 원하는 경우 기다려야하는 invalidation은 기다릴 수 있도록 커스텀할수도 있다.

```tsx
useMutation({
  mutationFn: updateLabel,
  meta: {
    invalidates: 'all',
    awaits: ['labels'],
  },
})
```

또는, 전역 콜백은 그냥 fire and forget으로 두고, `useMutation` 콜백측에서 중요한 invalidation의 반환값을 반환해서 해당 refetch가 끝날때까지 기다리게할 수 있다. 실행순서는 전역 콜백 → `useMutation` 콜백순이다.

```tsx
const queryClient = new QueryClient({
  mutationCache: new MutationCache({
    onSuccess: () => {
      queryClient.invalidateQueries()
    },
  }),
})

useMutation({
  mutationFn: updateLabel,
  onSuccess: () => {
    // returning the Promise to await it
    return queryClient.invalidateQueries(
      { queryKey: ['labels'] },
      { cancelRefetch: false }
    )
  },
})
```

여기서 `cancelRefetch`를 활용해서 전역 콜백에서 발생한 invalidation이 취소되지 않도록 해줬다.

## Concurrent Optimistic Updates

![](https://velog.velcdn.com/images/mskwon/post/ebd80ddb-aca2-43fe-88ae-c53cefd8a7ae/image.png)

`queryClient.isMutating` 메서드 + `mutationKey`를 이용해서 조건부로 `invalidateQueries` 를 호출해서 해결할 수 있다.

```tsx
const useToggleIsActive = (id: number) =>
  useMutation({
    mutationKey: ['items'],
    mutationFn: api.toggleIsActive,
    onMutate: async () => {
      await queryClient.cancelQueries({
        queryKey: ['items', 'detail', id],
      })

      queryClient.setQueryData(['items', 'detail', id], (prevItem) =>
        prevItem
          ? {
              ...prevItem,
              isActive: !prevItem.isActive,
            }
          : undefined
      )
    },
    onSettled: () => {
      if (queryClient.isMutating({ mutationKey: ['items'] }) === 1) {
        queryClient.invalidateQueries({
          queryKey: ['items', 'detail', id],
        })
      }
    },
  })
```

그러면 아래와 같은 흐름으로 데이터가 변화하게된다.

![](https://velog.velcdn.com/images/mskwon/post/fa029359-6412-4b5c-9d85-1fffd73d6c4f/image.png)


## `select` 최적화하기

`select` 연산이 굉장히 비싸다고 가정해보자.

```tsx
function ProductList({ filters }: Props) {
  const productsQuery = useSuspenseQuery({
    ...productListOptions(filters),
    select: (data) => expensiveSuperTransformation(data),
  })

  return (
    <ul>
      {productsQuery.data.map((product) => (
        <li>{product.summary}</li>
      ))}
    </ul>
  )
}
```

이 경우 코드는 잘 동작하겠지만, `expensiveSuperTransformation`이 매 렌더마다 호출되게된다. 왜 그런지 이해하려면 `select`가 언제 호출되는지를 알아야한다.

1. `data`가 변경될때
2. `select` 함수가 변경될때
    1. `select` 함수의 참조값을 확인한다

인라인 함수는 매 렌더마다 새로 만들어지기 때문에, 당연히 참조값이 바뀐다. 그래서 실질적으로 함수가 바뀌지 않았어도 매 렌더마다 `select` 함수가 호출되게 된다.

이를 해결하려면 `useCallback`를 사용해서 참조값을 안정시켜주면된다.

```tsx
function ProductList({ filters }: Props) {
  const productsQuery = useSuspenseQuery({
    ...productListOptions(filters),
    select: (data) => expensiveSuperTransformation(data),
  })

  return (
    <ul>
      {productsQuery.data.map((product) => (
        <li>{product.summary}</li>
      ))}
    </ul>
  )
}
```

의존성이 없다면 `useCallback`을 쓸 필요도 없다.

```tsx
const select = (data: Array<Product>) =>
  expensiveSuperTransformation(data)

function ProductList({ filters }: Props) {
  const productsQuery = useSuspenseQuery({
    ...productListOptions(filters),
    select,
  })

  return (
    <ul>
      {productsQuery.data.map((product) => (
        <li>{product.summary}</li>
      ))}
    </ul>
  )
}
```

하지만 `select` 옵션은 `QueryObserver` 범위에 해당하는 옵션이기 때문에, 여러군데서 호출되면 여전히 여러번 호출된다. 그래서 여기서 한술 더 뜨면 리액트쿼리 외부에서 memoization을 하도록 해서 별도 캐싱을 적용한 함수를 만들어서 사용할 수도 있다.

```tsx
import memoize from 'fast-memoize'

const select = memoize((data: Array<Product>) =>
  expensiveSuperTransformation(data)
)

function ProductList({ filters }: Props) {
  const productsQuery = useSuspenseQuery({
    ...productListOptions(filters),
    select,
  })

  return (
    <ul>
      {productsQuery.data.map((product) => (
        <li>{product.summary}</li>
      ))}
    </ul>
  )
}
```
