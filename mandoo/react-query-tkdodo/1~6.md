### `gcTime` VS `staleTime`
- `staleTime`
  - 쿼리가 `fresh` 상태에서 `stale` 상태로 바뀌는 데 걸리는 시간
  - 쿼리가 `fresh` 상태라면, 데이터는 항상 캐시에서 오게된다
  - 쿼리가 `stale` 상태라면, 데이터는 캐시에서 오지만, 조건에 따라 백그라운드 리페칭이 발생할 수 있다
- `gcTime`
  - `inactive` 쿼리가 캐시에서 지워지는 시간
  - 디폴트 값 = 5분
  - 등록된 옵저버가 없으면 `inactive` 상태로 변한다 -> 쿼리를 사용하는 모든 컴포넌트가 언마운트 된 시점
 
###  Data Transformation, 어디서 해야할까?

#### 백엔드에서 하기
가능하기만 하다면 제일 좋은 방법이다. 백엔드에서 원하는 형태로 데이터를 주는 것이다.

#### `queryFn`에서 하기
```ts
const fetchTodos = async (): Promise<Todos> => {
  const response = await axios.get('todos')
  const data: Todos = response.data

  return data.map((todo) => todo.name.toUpperCase())
}

export const useTodosQuery = () =>
  useQuery({
    queryKey: ['todos'],
    queryFn: fetchTodos,
  })
```
`queryFn`이 항상 백엔드에서 내려주는 데이터 그대로 반환할 필요는 없다. 여기서 원하는 데이터 변형을 해도 된다.

이 경우 네트워크 탭에서 왔다갔다 하는 데이터와 쿼리 캐시에 들어가있는 데이터의 형태가 달라지기 때문에 경우에 따라 약간 헷갈릴 수 있다. `fetch`가 발생할때마다 transformation이 발생할 것이고, 만약 이 변환 로직의 실행 비용이 많이 든다면 다른 방법을 고려해봐야한다.

#### 렌더 함수에서 하기
커스텀 훅을 사용하고 있다면, 커스텀 훅에서 변환을 수행해도 된다.

```tsx
const fetchTodos = async (): Promise<Todos> => {
  const response = await axios.get('todos')
  return response.data
}

export const useTodosQuery = () => {
  const queryInfo = useQuery({
    queryKey: ['todos'],
    queryFn: fetchTodos,
  })

  return {
    ...queryInfo,
    data: queryInfo.data?.map((todo) => todo.name.toUpperCase()),
  }
}
```

이 경우 변환 로직은 리렌더가 발생할때마다 실행된다. 이것이 문제된다면 `useMemo`를 사용하면된다. `useQuery`를 사용한다면 `data`가 `undefined`일때도 있으니, 옵셔널 체이닝을 사용하는 등 조심해야한다.

#### `select` 옵션 사용하기
```tsx
export const useTodosQuery = () =>
  useQuery({
    queryKey: ['todos'],
    queryFn: fetchTodos,
    select: (data) => data.map((todo) => todo.name.toUpperCase()),
  })
```
`select` 함수는 데이터가 있을때만 호출되며, 따라서 `undefined` 케이스에 대해서 고려하지 않아도 된다. 하지만 `select` 함수를 인라인 함수로 선언하면 매 리렌더마다 호출되기 때문에 `useCallback`이나 stable한 함수 선언으로 대체해주는 것이 좋다.

```tsx
const transformTodoNames = (data: Todos) =>
  data.map((todo) => todo.name.toUpperCase())

export const useTodosQuery = () =>
  useQuery({
    queryKey: ['todos'],
    queryFn: fetchTodos,
    // ✅ uses a stable function reference
    select: transformTodoNames,
  })

export const useTodosQuery = () =>
  useQuery({
    queryKey: ['todos'],
    queryFn: fetchTodos,
    // ✅ memoizes with useCallback
    select: React.useCallback(
      (data: Todos) => data.map((todo) => todo.name.toUpperCase()),
      []
    ),
  })
```

`select` 옵션을 사용하면 `data`의 일부분에만 구독할 수 있게된다.
```tsx
export const useTodosQuery = (select) =>
  useQuery({
    queryKey: ['todos'],
    queryFn: fetchTodos,
    select,
  })

export const useTodosCount = () =>
  useTodosQuery((data) => data.length)
export const useTodo = (id) =>
  useTodosQuery((data) => data.find((todo) => todo.id === id))
```
위 코드의 경우, 특정 `todo`의 `name` 프로퍼티가 변경됐더라도 `useTodosCount`에는 리렌더링이 발생하지 않게된다.

### `Tracked Queries`
```tsx
// isRefetching 값이 변할때만 리렌더링이 발생한다
const { isRefetching } = useQuery({
  queryKey: ['todos'],
  queryFn: fetchTodos,
})
```

리액트 쿼리는 "알아서" 렌더링 중에 사용하는 필드들을 추적하고 리스트를 만들어준다. 이는 `notifyOnChangeProps: 'tracked'` 옵션의 영향으로, v4부터 디폴트 옵션이 되었다. 이 옵션 덕분에 실제로 사용하는 필드 값에 변화가 있을때만 리렌더링이 발생한다. 물론 이 "추적"을 위해서 약간의 오버헤드가 있고, 몇가지 한계가 있긴하다.

구조분해할당시 모든 필드에 대해 notify 받게된다.
```tsx
// 🚨 will track all fields
const { isLoading, ...queryInfo } = useQuery(...)

// ✅ this is totally fine
const { isLoading, data } = useQuery(...)
```

렌더링 도중에만 동작한다. 이펙트에서 필드에 접근하면 추적되지 않는다. 하지만 의존성 배열에 필드가 들어가면 마찬가지로 동작한다.
```tsx
const queryInfo = useQuery(...)

// 🚨 will not corectly track data
React.useEffect(() => {
    console.log(queryInfo.data)
})

// ✅ fine because the dependency array is accessed during render
React.useEffect(() => {
    console.log(queryInfo.data)
}, [queryInfo.data])
```

매 렌더마다 리셋되지 않는다. 한번 필드를 추적했다면 옵저버의 수명동안 계속 추적한다.
```tsx
const queryInfo = useQuery(...)

if (someCondition()) {
    // 🟡 we will track the data field if someCondition was true in any previous render cycle
    return <div>{queryInfo.data}</div>
}
```
### Structural Sharing
리액트 쿼리의 "Structural Sharing" 기능 덕에 `data`의 참조값을 모든 레벨에서 유지할 수 있다. 아래와 같은 데이터가 있을 때,
```tsx
[
  { "id": 1, "name": "Learn React", "status": "active" },
  { "id": 2, "name": "Learn React Query", "status": "todo" }
]
```

첫번째 todo를 done 상태로 바꾸고 백그라운드 리페칭을 수행하면, 새로운 JSON을 받게 될 것이다.
```diff
[
-  { "id": 1, "name": "Learn React", "status": "active" },
+  { "id": 1, "name": "Learn React", "status": "done" },
  { "id": 2, "name": "Learn React Query", "status": "todo" }
]
```

리액트 쿼리는 예전 상태와 새로운 상태를 비교한 뒤, 이전 상태를 가능한 유지하려고 시도한다. 위의 예시에서 첫번째 todo는 새로운 것으로 대체되지만, 두번째 todo는 같은 참조값을 유지하게된다. 이 덕분에 `select` 옵션이 더욱 유용해진다.

```tsx
// ✅ will only re-render if _something_ within todo with id:2 changes
// thanks to structural sharing
const { data } = useTodo(2)
```

하지만 `select` 옵션을 사용하면, 내부적으로 구조적 공유가 두번 발생하게된다. 첫번째로 `queryFn`에서 온 데이터가 변경되었을 때 한번, 두번째로 `select` 함수의 결과가 바뀌었을 때 한번.

이로 인해서 데이터셋이 큰 경우 구조적 공유가 병목이 될 수도 있다. 또한, JSON 직렬화 가능한 값에 대해서만 구조적 공유는 동작한다. 만약 구조적 공유가 필요하지 않다면, `structuralSharing: false`로 설정해주면된다.

### 백그라운드 리페칭 에러
대부분의 상황에서, 백그라운드 리페칭이 실패하면 조용히 무시될 수 있다. 하지만, 코드가 작성되 방식에 따라서 아닐수도 있다. 최초 데이터페칭은 성공했으나, 백그라운드 리페칭이 실패했다면, 해당 쿼리는 아래와 같은 상태가 된다.
```tsx
{
  "status": "error",
  "error": { "message": "Something went wrong" },
  "data": [{ ... }]
}
```

`error`와 `data`를 모두 가지고 있는 상태가 되는 것이다. 이 경우에, 화면이 어떻게 보일지는 개발자가 잘 판단해서 코드를 작성해야한다. stale한 데이터라도 보여주고 싶다면 아래와 같이 `render` 함수를 작성하면 된다.

```tsx
const todos = useTodos()

if (todos.data) {
  return <div>{todos.data.map(renderTodo)}</div>
}
if (todos.error) {
  return 'An error has occurred: ' + todos.error.message
}

return 'Loading...'
```

### 제네릭과 자동 타입 추론
현재 `useQuery`의 타입스크립트 시그니처는 아래와 같다.
```tsx
export function useQuery<
  TQueryFnData = unknown,
  TError = unknown,
  TData = TQueryFnData,
  TQueryKey extends QueryKey = QueryKey
>
```
- `TQueryFnData`
    - `queryFn`이 반환하는 타입
- `TError`
    - `queryFn`이 뱉을 수 있는 에러 타입
- `TData`
    - `data` 프로퍼티가 최종적으로 가지게 될 타입
    - `select` 옵션을 쓸때만 필요함(아니면 그냥 `TQueryData`랑 같음)
- `TQueryKey`
    - `queryKey`의 타입
    - `queryFn`에게 넘기는 `queryKey`를 사용할때만 필요함
 
뭔가 복잡해보이지만, 대부분의 케이스에 타입 추론의 도움으로 적절한 타입들이 잘 들어가게 된다. 단, 이것이 제대로 동작하려면 기본적으로 `queryFn`이 적절한 반환 타입을 가지고 있어야한다. 이 조건만 잘 맞춰준다면 아름답게 추론되는 제네릭 타입들을 볼 수 있다.

```tsx
function fetchGroups(): Promise<Group[]> {
  return axios.get('groups').then((response) => response.data)
}

// ✅ data will be `Group[] | undefined` here
function useGroups() {
  return useQuery({ queryKey: ['groups'], queryFn: fetchGroups })
}

// ✅ data will be `number | undefined` here
function useGroupCount() {
  return useQuery({
    queryKey: ['groups'],
    queryFn: fetchGroups,
    select: (groups) => groups.length,
  })
}
```

### 에러 타이핑
원래는 아무 제네릭이 없다면 에러는 `unknown`으로 추론되었다. 하지만 이는 v4부터 `Error`로 대체되었다. 대부분의 케이스에는 `Error`가 던져지긴 하기 때문이다. 원한다면 module augmentation을 통해서 디폴트 에러에 타입을 지정할 수도 있다.

```tsx
declare module '@tanstack/react-query' {
  interface Register {
    defaultError: AxiosError
  }
}
```

### `enabled` 옵션과 타입 안정성
`enabled`는 훌륭한 옵션이지만, 타입 안정성 면에서는 아쉬움이 있다.
```tsx
function fetchGroup(id: number): Promise<Group> {
  return axios.get(`group/${id}`).then((response) => response.data)
}

function useGroup(id: number | undefined) {
  return useQuery({
    queryKey: ['group', id],
    queryFn: () => fetchGroup(id),
    enabled: Boolean(id),
  })
  // 🚨 Argument of type 'number | undefined' is not assignable to parameter of type 'number'.
  //  Type 'undefined' is not assignable to type 'number'.ts(2345)
}
```
non-null assertion을 사용하는 방법, `queryFn`에서 `undefined`를 허용하되 reject를 해버리는 방법 등이 있지만, 5.25 버전부터 좀 더 우아하게 이 케이스를 처리할 수 있는 방법이 생겼다.

```tsx
import { useQuery, skipToken } from '@tanstack/query'

function useGroup(id: number | undefined) {
  return useQuery({
    queryKey: ['group', id],
    queryFn: id ? () => fetchGroup(id) : skipToken,
  })
}
```

### 낙관적 업데이트
v5부터 낙관적 업데이트를 할 수 있는 새로운 방법이 제시되어서, 더 쉽게 낙관적 업데이트 코드를 작성할 수 있다고 한다.

```tsx
const addTodoMutation = useMutation({
  mutationFn: (newTodo: string) => axios.post('/api/data', { text: newTodo }),
  // make sure to _return_ the Promise from the query invalidation
  // so that the mutation stays in `pending` state until the refetch is finished
  onSettled: () => queryClient.invalidateQueries({ queryKey: ['todos'] }),
})

const { isPending, submittedAt, variables, mutate, isError } = addTodoMutation
```

`variables`에는 추가하려고하는 Todo 데이터가 담기게된다. 이 값을 활용해서 mutation이 `isPending` 상태인 동안에만 새로운 아이템을 추가로 렌더링해주면된다.

```tsx
<ul>
  {todoQuery.items.map((todo) => (
    <li key={todo.id}>{todo.text}</li>
  ))}
  {isPending && <li style={{ opacity: 0.5 }}>{variables}</li>}
</ul>
```

mutation이 끝나면 자연스럽게 해당 아이템은 사라지게 된다.

Mutation 도중 에러가 발생해서 실패하게 된다고 해도, 원한다면 추가 코드 작성을 통해서 재시도 UI를 만들 수도 있다.
```tsx
{
  isError && (
    <li style={{ color: 'red' }}>
      {variables}
      <button onClick={() => mutate(variables)}>Retry</button>
    </li>
  )
}
```

이것을 중개 어드민 프로젝트에서 실제로 한번 시험해봤는데, Mutation의 `isPending`이 리페칭이 끝날때까지 잘 유지되도록 코드를 작성해주면 UI가 굉장히 스무스하게 동작해서 앞으로 낙관적 업데이트를 넣고자 할때 애용할 것 같다. 기존에 `setQueryData`를 이용하는 방식은 뭔가 코드도 복잡하고 굉장히 묘하게 안정적이지 않은 느낌이 들었어서 잘 안썼었다.
