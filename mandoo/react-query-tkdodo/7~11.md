## ReactQuery - WebSocket 활용방안

서버에서 데이터 변경이 있을때 WebSocket을 통해서 클라이언트에 알리고, 클라이언트에서 상황에 따라 invalidation을 하거나, setQueryData를 하는 방법으로 쓸 수 있음

```tsx
const useReactQuerySubscription = () => {
  const queryClient = useQueryClient()
  React.useEffect(() => {
    const websocket = new WebSocket('wss://echo.websocket.org/')
    websocket.onopen = () => {
      console.log('connected')
    }
    websocket.onmessage = (event) => {
      const data = JSON.parse(event.data)
      const queryKey = [...data.entity, data.id].filter(Boolean)
      queryClient.invalidateQueries({ queryKey })
    }

    return () => {
      websocket.close()
    }
  }, [queryClient])
}
```

WebSocket을 “제대로” 활용해서 제때제때 업데이트해준다는 확신이 있다면, `staleTime`을 `Infinity`로 설정해도 무방. 데이터가 변경되면 서버에서 알려줄거기때문에.

```tsx
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: Infinity,
    },
  },
})
```

## `useQuery` - `useInfiniteQuery` 쿼리키 공유금지

`useQuery` 훅과 `useInfiniteQuery`는 저장하는 데이터의 형태가 다르다. 같은 쿼리키를 사용하는 경우, 서로가 서로의 데이터를 덮어씌우는 상황이 발생해서 오류가 날 가능성이 높아진다.

따라서 서로 다른 쿼리키를 사용해야한다.

## 쿼리키 구조 잡기

배열 쿼리키를 사용할 때, Generic → Specific 순으로 순서를 설정해주면 좋다. invalidation을 유연하게 할 수 있게 되기 때문이다.

```tsx
['todos', 'list', { filters: 'all' }]
['todos', 'list', { filters: 'done' }]
['todos', 'detail', 1]
['todos', 'detail', 2]
```

배열 형태의 쿼리키보다 좋은 것은 객체 형태의 배열키다. 꺼내서 쓸때 named destructuring도 가능하고, query invalidation을 위한 fuzzy matching은 객체에 대해서도 잘 동작한다.

```tsx
// 🕺 remove everything related to the todos feature
queryClient.removeQueries({
  queryKey: [{ scope: 'todos' }]
})

// 🚀 reset all todo lists
queryClient.resetQueries({
  queryKey: [{ scope: 'todos', entity: 'list' }]
})

// 🙌 invalidate all lists across all scopes
queryClient.invalidateQueries({
  queryKey: [{ entity: 'list' }]
})
```

## `QueryFunctionContext`

`QueryFunctionContext`는 `queryFn`에게 넘겨지는 인자다. 리액트쿼리는 이 값을 이용해서 `queryFn`에게 쿼리에 대한 정보를 최대한 넘겨준다. Infinite query의 경우에는 `getNextPageParam`의 반환값이 `pageParam`으로 `QueryFunctionContext`에 포함되어 넘겨진다.

```tsx
// this is the QueryFunctionContext ⬇️
const fetchProjects = ({ pageParam }) =>
  fetch('/api/projects?cursor=' + pageParam)

useInfiniteQuery({
  queryKey: ['projects'],
  queryFn: fetchProjects,
  getNextPageParam: (lastPage) => lastPage.nextCursor,
  initialPageParam: 0,
})
```

`QueryFunctionContext`에는 `queryKey`도 포함된다. 리액트쿼리는 `queryKey`를 기준으로 새로운 요청을 보낼지 말지 결정하기 때문에, `queryFn`에서 `queryKey`에 포함되지 않는 값을 사용하는 것이 권장되지 않는다. 따라서, `QueryFunctionContext`를 최대한 활용해서,  `queryFn`을 순수함수로 작성해주는 것이 좋다.

```tsx
const fetchTodos = async ({ queryKey }) => {
  // 🚀 we can get all params from the queryKey
  const [, state, sorting] = queryKey
  const response = await axios.get(`todos/${state}?sorting=${sorting}`)
  return response.data
}

export const useTodos = () => {
  const { state, sorting } = useTodoParams()

  // ✅ no need to pass parameters manually
  return useQuery({
    queryKey: ['todos', state, sorting],
    queryFn: fetchTodos,
  })
}
```

이럴때 `queryKey` 배열 내에 객체가 있는 것이 또 도움이 된다. named destructuring을 통해서 편하게 원하는 값을 꺼내쓸 수 있기 때문이다.

```tsx
const todoKeys = {
  // ✅ all keys are arrays with exactly one object
  all: [{ scope: 'todos' }] as const,
  lists: () => [{ ...todoKeys.all[0], entity: 'list' }] as const,
  list: (state: State, sorting: Sorting) =>
    [{ ...todoKeys.lists()[0], state, sorting }] as const,
}

const fetchTodos = async ({
  // ✅ extract named properties from the queryKey
  queryKey: [{ state, sorting }],
}: QueryFunctionContext<ReturnType<typeof todoKeys['list']>>) => {
  const response = await axios.get(`todos/${state}?sorting=${sorting}`)
  return response.data
}

export const useTodos = () => {
  const { state, sorting } = useTodoParams()

  return useQuery({
    queryKey: todoKeys.list(state, sorting),
    queryFn: fetchTodos
  })
}
```

## Cache 레벨 쿼리옵션 VS Observer 레벨 쿼리옵션

### Cache 레벨 쿼리옵션

각 쿼리키에 대해서 캐시 엔트리는 하나만 존재한다. 우리가 `useQuery`에 넘기는 옵션들 중 일부는 캐시 엔트리에 영향을 주게된다.

- `queryFn`
    - 캐시 엔트리에 어떤 데이터를 채워넣을지 정함
- `gcTime`
    - 캐시 엔트리가 언제 가비지 콜렉션 되는지 정함

### Observer 레벨 쿼리옵션

옵저버는 넓은 의미에서 하나의 캐시엔트리에 대해 만들어진 Subscription이다. 옵저버는 캐시 엔트리를 보고 있다가, 뭔가 변화하면 inform 받게되어서 리렌더링을 발생시킨다.

옵저버를 만드는 가장 간단한 방법은 `useQuery`를 호출하는 것으로, 호출이 발생할때 옵저버가 하나 생성되며 해당 컴포넌트는 데이터가 변경될때마다 리렌더링을 수행하게된다. 하나의 캐시 엔트리에 대해서 여러개의 옵저버가 생성될 수 있다.

옵저버 레벨에서 동작하는 옵션들의 예는 아래와 같다.

- `select`
    - 옵저버 레벨에서 데이터 변환을 수행 (캐시 엔트리에는 영향을 안줌)
- `refetchInterval`
    - 얼마나 자주 데이터를 refetch 할지 정함

## `placeholderData` VS `initialData`

둘은 동기적으로 리액트 쿼리 캐시를 채워넣는 서로 다른 방법이다.

### **유사한 점**

- `placeholderData` 또는 `initialData`가 존재한다면, 쿼리의 상태가 `loading`이 되지 않으며 바로 `success`가 된다.
- 값이 될수도 있고, 값을 반환하는 함수가 될 수도 있다.
- 캐시에 이미 데이터가 있다면 아무런 효과가 없다.

### 차이점

**`initialData`는 캐시레벨에서 동작한다. `placeholderData`는 옵저버 레벨에서 동작한다.**

- 영속성
    - `initialData`
        - 캐시에 **영속적**으로 저장된다. **리액트 쿼리에게 백엔드에서 받아온 데이터처럼 쓸만한 데이터가 있다. 라고 알리고 저장해두는 셈**이다.
        - 캐시레벨에서 동작 → 하나의 `initialData`만 있을 수 있으며 캐시 엔트리가 만들어질 때 데이터가 들어가게 됨. 이미 들어가있는 상태에서 새로운 데이터를 넣으려고 하면 아무 동작도 하지 않음
    - `placeholderData`
        - 캐시에 영속되지 않는다. “fake-it-till-you-make-it” 동작을 한다.
        - 실제 데이터를 페칭하는 도중에 다른 뭔가 보여줄 옵션을 제공
        - 옵저버 레벨에서 동작 → 옵저버별로 서로 다른 `placeholderData`를 가질 수 있음
- 백그라운드 리페칭
    - `initialData`
        - 유효한 데이터라고 판단 → `staleTime`이 적용된다. `staleTime`이 0이라면 곧바로 백그라운드 리페칭 수행
        - `initialData`가 언제 만들어졌는지 알려주고 싶다면, `initialDataUpdatedAt` 옵션을 넘기면 됨 → 이 시간을 기준으로 `stale`한지 아닌지 판단
    - `placeholderData`
        - 옵저버를 처음 마운트할때 항상 백그라운드 리페칭 수행
        - 리페칭하는 동안 `isPlaceholderData` 플래그 값을 `true`로 반환해줌
- 백그라운드 리페칭 에러 발생시 상태 변화
    - `initialData`
        - 백그라운드 리페칭이 실패하면 `isError`가 `true`가 되지만, `data`도 여전히 존재함
    - `placeholderData`
        - 백그라운드 리페칭이 실패하면 `isError`도 `true`, `data`는 `undefined`가 됨

### 어떻게 사용할까?

`initialData`는 주로 다른 쿼리에서 온 값을 초기값으로 사용할 때 사용, 그 외에는 `placeholderData` 사용. 하지만 어떻게 사용할지는 개발자 맘

## `setQueryDefaults`

특정 쿼리키/쿼리키들에 대해서만 다른 default option을 설정하고 싶다면, `queryClient.setQueryDefaults` 메서드를 사용하면된다. 쿼리키는 `invalidateQueries` 호출할때처럼 넘겨주면 됨.

```tsx
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      // ✅ globally default to 20 seconds
      staleTime: 1000 * 20,
    },
  },
})

// 🚀 everything todo-related will have
// a 1 minute staleTime
queryClient.setQueryDefaults(
  todoKeys.all,
  { staleTime: 1000 * 60 }
)
```

## 리액트쿼리 에러핸들링 방법

일단 리액트 쿼리는 **Promise가 reject를 해줘야** 에러 핸들링에 대한 상태 변화도 제대로 발생하고, 의도된 방식대로 에러처리를 할 수 있다. 만약 native fetch 등을 써서 Promsie가 reject를 하고 있지 않다면, `queryFn`에서 직접 추가적인 처리를 해야할 수 있다.

### 에러 처리하는 방법 3가지

- `useQuery`가 반환하는 `isError`, `error` 프로퍼티 활용
    - 간단하고 흔한 방법
        
        ```tsx
        function TodoList() {
          const todos = useQuery({
            queryKey: ['todos'],
            queryFn: fetchTodos
          })
        
          if (todos.isPending) {
            return 'Loading...'
          }
        
          // ✅ standard error handling
          // could also check for: todos.status === 'error'
          if (todos.isError) {
            return 'An error occurred'
          }
        
          return (
            <div>
              {todos.data.map((todo) => (
                <Todo key={todo.id} {...todo} />
              ))}
            </div>
          )
        }
        ```
        
- `onError` 콜백
    - `onError` 옵션을 통해서 에러가 발생했을때의 로직을 지정해줄 수 있음 → v5부터 쿼리 레벨에서는 더이상 이 옵션을 설정할 수 없고(커스텀 훅으로 선언해서 여기저기서 사용할 때, 에러는 한번났는데 `onError`는 여러번 호출되는 문제가 있었음), 쿼리캐시 레벨에서 지정해줄 수 있음
        
        ```tsx
        const queryClient = new QueryClient({
          queryCache: new QueryCache({
            onError: (error, query) => {
              // 🎉 only show error toasts if we already have data in the cache
              // which indicates a failed background update
              if (query.state.data !== undefined) {
                toast.error(`Something went wrong: ${error.message}`)
              }
            },
          }),
        })
        ```
        
- `ErrorBoundary` 활용
    - `throwOnError`를 통해서 에러를 던지도록 설정해주면, 렌더 사이클에 리액트 쿼리가 에러를 던져서 에러바운더리가 작동하도록 만들어준다.
    - **`throwOnError`에는 함수도 넘길 수 있다**
        
        ```tsx
        useQuery({
          queryKey: ['todos'],
          queryFn: fetchTodos,
          // 🚀 only server errors will go to the Error Boundary
          throwOnError: (error) => error.response?.status >= 500,
        })
        ```