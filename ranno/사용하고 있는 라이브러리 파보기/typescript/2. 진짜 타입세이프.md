
# **진정한 타입세이프란 무엇일까?**

많은 분들이 타입세이프라고 하면 런타임에 에러가 나지 않는 코드, 혹은 타입 오류가 있을 때 빌드 시점에서 컴파일러가 잡아주는 것을 떠올리실 겁니다. 물론 이것도 중요하지만, **"내가 의도하지 않은 타입이 나타나지 않는 것"**입니다.

이는 우리가 비즈니스 요구사항(실제 세상의 타입)을 코드로 표현하고, 그 코드가 빌드되어 런타임에 동작하는 이 세 가지 단계의 타입이 **모두 일치**하는 것을 의미합니다. 마치 비즈니스 스펙이라는 도면, 코드로 구현된 설계도, 그리고 실제 동작하는 건축물이 완벽하게 조화를 이루는 것에 비유할 수 있죠.

예를 들어, 당근마켓의 채팅 메시지는 텍스트와 이미지 두 가지 종류가 있다고 가정해봅시다. 만약 코드를 짤 때 `imageUrl`과 `plainText` 필드를 모두 `nullable`로 두면, 실제 세상에는 존재하지 않는 **'이미지도 아니고 텍스트도 아닌'** 메시지 타입이 코드상에 존재할 수 있게 됩니다. 이는 우리가 의도하지 않은 타입이 나타난 대표적인 예시이며, 이러한 상황을 방지하는 것이 진정한 타입세이프의 핵심입니다.


```typescript
// ⛔️ 문제점: 의도하지 않은 타입이 나타날 수 있는 코드 : image나 plainText 하나는 있어야 함
type ChatMessage = {
    messageType: string;
    imageUrl?: string | null; // 이미지 URL은 선택적이고 널 가능
    plainText?: string | null; // 일반 텍스트도 선택적이고 널 가능
};

// ❌ 예시 1: 실제 세상에 존재하지 않는 messageType
const problematicMessage1: ChatMessage = {
    messageType: 'abc', // 'abc' 타입은 존재하지 않지만 코드상에서는 허용됨
    imageUrl: null,
    plainText: null,
};

// ❌ 예시 2: 내용이 없는 메시지 (이미지도 텍스트도 아닌)
const problematicMessage2: ChatMessage = {
    messageType: 'plainText', // 또는 'image'
    imageUrl: null, // 이미지가 없으면서
    plainText: null, // 텍스트도 없음
};
```

<br/>
<br/>
<br/>

## **타입스크립트에서 타입세이프하게 코드를 작성하는 방법**

그렇다면 어떻게 하면 이런 '의도하지 않은 타입'의 등장을 막고, 더욱 견고한 코드를 만들 수 있을까

### *유니온 타입(Union Type)을 활용한 비즈니스 스펙 타입 모델링**
*   **문제점**: 위에서 언급했듯이, 하나의 타입 안에 여러 속성을 선택적으로 `nullable`하게 두거나 문자열 상수만으로 타입을 구분하려 하면, 실제 비즈니스 로직에서 허용하지 않는 **불가능한 조합의 타입이 코드상에 나타날 수 있습니다**. 심지어는 정의되지 않은 `messageType` (예: "abc" 같은 값)도 허용될 수 있죠.
*   **해결책**: **타입스크립트의 유니온 타입**을 활용하여 각 비즈니스 스펙에 맞는 **명확히 분리된 인터페이스**를 정의하는 것입니다. 예를 들어, `ImageChatMessage`와 `PlainTextChatMessage`를 각각 정의하고, 각 인터페이스에 고유한 `messageType` (예: `"image"`, `"plainText"`)과 필수 속성들을 명시하는 방식입니다. 그리고 이 두 타입을 `ImageChatMessage | PlainTextChatMessage`와 같이 유니온으로 묶어줍니다.
*   **효과**: 이렇게 하면 컴파일러가 `messageType`에 따라 `imageUrl` 또는 `plainText` 중 어떤 필드가 필요한지 정확히 추론하게 되며, 개발자가 의도하지 않은 조합이나 정의되지 않은 타입의 객체를 생성하려고 하면 **즉시 컴파일 에러**를 발생시켜 런타임 오류를 사전에 방지합니다.

다음은 유니온 타입을 활용하여 개선된 코드 예시입니다:

```typescript
// ✅ 개선: 유니온 타입을 활용한 타입 모델링
interface ImageChatMessage {
    id: string; // 공통 필드
    messageType: 'image'; // 메시지 타입은 'image'로 고정
    imageUrl: string; // 이미지 메시지는 반드시 imageUrl을 가짐 (null 아님)
    senderNickname: string; // 발신자 닉네임 (나중에 추가되는 필드)
}

interface PlainTextChatMessage {
    id: string; // 공통 필드
    messageType: 'plainText'; // 메시지 타입은 'plainText'로 고정
    plainText: string; // 텍스트 메시지는 반드시 plainText를 가짐 (null 아님)
    senderNickname: string; // 발신자 닉네임
}

// 이모티콘 메시지 타입 추가 (패턴 매칭 예시를 위해)
interface EmoticonChatMessage {
    id: string;
    messageType: 'emoticon'; // 메시지 타입은 'emoticon'으로 고정
    emoticonId: string; // 이모티콘 ID
    senderNickname: string; // 발신자 닉네임
}

// 두 (혹은 세) 타입을 유니온으로 묶어 실제 세상의 채팅 메시지를 표현
type ChatMessage = ImageChatMessage | PlainTextChatMessage | EmoticonChatMessage;

// 🟢 예시 1: 유효한 이미지 메시지
const validImageMessage: ChatMessage = {
    id: 'img-001',
    messageType: 'image',
    imageUrl: 'https://example.com/photo.jpg',
    senderNickname: '당근이',
};

// 🟢 예시 2: 유효한 텍스트 메시지
const validTextMessage: ChatMessage = {
    id: 'text-002',
    messageType: 'plainText',
    plainText: '안녕하세요, 채팅 테스트입니다!',
    senderNickname: '마켓지기',
};

// 🟡 예시 3: 유효한 이모티콘 메시지
const validEmoticonMessage: ChatMessage = {
    id: 'emo-003',
    messageType: 'emoticon',
    emoticonId: 'happy-01',
    senderNickname: '이모티',
};

// ❌ 예시 4: 존재하지 않는 messageType -> 컴파일 에러 발생!
const invalidMessage1: ChatMessage = {
    id: 'err-001',
    messageType: 'abc', // Type '"abc"' is not assignable to type '"image" | "plainText" | "emoticon"'.
    imageUrl: '...',
    plainText: '...',
};

// ❌ 예시 5: 이미지 메시지에 plainText를 정의 -> 컴파일 에러 발생!
const invalidMessage2: ChatMessage = {
    id: 'err-002',
    messageType: 'image',
    imageUrl: 'https://example.com/photo.jpg',
    plainText: '사진 메시지에 텍스트가 있을 수 없음', // Object literal may only specify known properties, and 'plainText' does not exist in type 'ImageChatMessage'.
};
```

<br/>

###  **패턴 매칭(Pattern Matching)을 활용한 타입세이프한 로직 구현**
* 패턴 매칭(pattern matching)이란 데이터의 특정 패턴이 나타나는지 확인하고, 그 패턴에 따라 다른 작업을 수행하는 프로그래밍 기법 
*   **문제점**: 복잡한 애플리케이션에서는 다양한 타입에 따라 다른 로직을 수행해야 할 때가 많습니다. 이때 흔히 `if-else` 또는 `switch-case` 문을 사용하게 되는데, 새로운 타입이 추가되었을 때 해당 분기 처리 로직을 빠뜨리면 **런타임에 버그가 발생**할 수 있습니다.
*   **해결책**: **패턴 매칭**은 이런 분기 처리 로직을 훨씬 더 타입세이프하게 만들어줍니다. 패턴 매칭(pattern matching)이란 데이터의 특정 패턴이 나타나는지 확인하고, 그 패턴에 따라 다른 작업을 수행하는 프로그래밍 기법으로 switch문을 이용해 구현할 수 있습니다.

    ```typescript
    // ✅ 개선: 패턴 매칭 아이디어를 활용한 로직 구현
    function sendMessageNotification(message: ChatMessage) {
        // 메시지 타입에 따라 알림 문구를 다르게 생성
        switch (message.messageType) {
            case 'image':
                // message가 ImageChatMessage 타입으로 추론됨
                console.log(`${message.senderNickname}님이 사진을 보냈어요`);
                break;
            case 'plainText':
                // message가 PlainTextChatMessage 타입으로 추론됨
                console.log(message.plainText);
                break;
            // 🚨 이모티콘 타입이 추가되었지만 처리되지 않은 경우, 아래 default에서 컴파일 에러 발생!
            // case 'emoticon':
            //     // message가 EmoticonChatMessage 타입으로 추론됨
            //     console.log(`${message.senderNickname}님이 이모티콘을 보냈어요`);
            //     break;
            default:
                // 모든 가능한 ChatMessage 타입이 switch 문에서 처리되었음을 보장
                // 만약 새로운 messageType이 추가되고 여기에 case가 없다면,
                // 'message'는 'never' 타입이 될 수 없으므로 컴파일 에러 발생
                const _exhaustiveCheck: never = message;
                return _exhaustiveCheck;
        }
    }

    // 예시 사용:
    sendMessageNotification({
        id: 'img-001',
        messageType: 'image',
        imageUrl: 'https://example.com/photo.jpg',
        senderNickname: '당근이',
    }); // 출력: "당근이님이 사진을 보냈어요"

    sendMessageNotification({
        id: 'text-002',
        messageType: 'plainText',
        plainText: '오늘 날씨 좋네요!',
        senderNickname: '이웃주민',
    }); // 출력: "오늘 날씨 좋네요!"

    // 🚨 만약 위 switch 문에 'emoticon' case가 없다면, 아래 호출은 컴파일 오류를 유발
    // sendMessageNotification({
    //     id: 'emo-003',
    //     messageType: 'emoticon',
    //     emoticonId: 'smile-01',
    //     senderNickname: '스마일맨',
    // });
    ```

#### 이걸 편하게 만들어주는 `ts-pattern`이라는 라이브러리가 있습니다.
패턴 매칭을 사용하면, 특정 유니온 타입(예: `ChatMessage`)의 모든 가능한 케이스(예: `image`, `plainText`, `emoticon`)를 **명시적으로 처리하도록 강제**합니다. 만약 기존에 `image`와 `plainText`만 처리하던 메시지 타입에 `emoticon` 타입이 새롭게 추가되면, 컴파일러는 즉시 "이모티콘 타입을 아직 고려하지 않았다"며 **빨간 줄(컴파일 에러)**을 띄웁니다. 이는 런타임에 발생할 수 있는 잠재적인 버그를 **빌드 시점에 미리 발견**하고 수정할 수 있게 해주어, 로직을 더욱 견고하게 만듭니다. switch문으로 우리가 직접 작성할 때는, 특정 케이스가 추가되어 처리를 누락했을지언정 알 수 있는 방법이 없다. 런타임에 오류가 나서야 알게 될 확률이 높은데 `ts-pattern`을 사용하면 처리되지 않은 경우에 대해선 ts-error를 내보내주니 배포 나가기 전에 알 수 있다. 

```ts
const sendNotification = (chatMessage : ChatMessage) => {
    match(chatMessage)
        .with({ messageType : "image" }, () => {})
        .with({ messageType : "plainText" }, () => {})
        .with({ messageType : "emoticon" }, () => {})  // 하나의 케이스라도 없으면 typescript error 발생 
        .exhaustive()  // 모든 가능한 값이 처리되었는지 체크
}
```

그러나 ts-pattern은 다양한 데이터 구조와 복잡한 타입 추론을 지원하기 위해, `exhaustive()`로 입력 타입의 가능한 모든 경우를 사전에 계산하는데. 내부 코드를 살펴보면 match.ts 파일에서는 클래스 기반으로 패턴 매칭을 구현하고, this를 사용해 상태를 함수 체이닝을 통해 공유합니다. 이러한 방식은 안전한 타입 매칭을 제공하지만, 자바스크립트 엔진이 최적화된 기본 if/else와 비교하면 성능이 떨어질 수밖에 없다.


<br/>

### **외부 값에 대한 엄격한 밸리데이션(Validation)** 
*   **문제점**: 애플리케이션의 외부에서 들어오는 값(예: 서버로 전송된 HTTP 요청 본문, 클라이언트의 입력값)은 우리가 정의한 타입과 일치하지 않거나 "오염된" 값일 수 있습니다. 타입스크립트는 런타임에 강타입 언어가 아니므로, 단순히 `as` 키워드를 사용하여 강제 형 변환하는 것은 타입 체크를 무시하는 것이므로 **타입세이프하지 않습니다**. 이러한 오염된 값이 비즈니스 로직으로 유입되면 예측 불가능한 버그를 유발할 수 있습니다.
*   **해결책**: 외부에서 들어오는 모든 값에 대해 **밸리데이션 라이브러리**를 사용하여 유효성을 검사해야 합니다.
*   **효과**: 밸리데이션 라이브러리를 사용하면, 들어오는 데이터가 우리가 정의한 스키마(타입)에 맞는지 **런타임에 검증**하고, 만약 일치하지 않으면 적절한 오류 처리(예: 400 Bad Request)를 할 수 있습니다. 밸리데이션을 통과한 데이터만이 **안전한 타입**으로 비즈니스 로직에 전달되어, 외부로부터의 **"오염된 타입"으로부터 우리 코드를 보호**할 수 있습니다. 이는 서버 코드뿐만 아니라 클라이언트나 다른 외부 애플리케이션에서 오는 모든 값에 적용하는 것이 좋습니다.
 

```typescript
// ✅ 개선: Zod를 사용한 외부 값 밸리데이션
// Zod 설치: npm install zod
import { z } from 'zod'; // Zod 라이브러리 import

// 우리가 정의한 ChatMessage 타입에 상응하는 Zod 스키마 정의
const ImageChatMessageSchema = z.object({
    id: z.string(),
    messageType: z.literal('image'), // 'image' 문자열 상수로 고정
    imageUrl: z.string(), // 문자열이어야 함
});

const PlainTextChatMessageSchema = z.object({
    id: z.string(),
    messageType: z.literal('plainText'), // 'plainText' 문자열 상수로 고정
    plainText: z.string(), // 문자열이어야 함
});

const EmoticonChatMessageSchema = z.object({
    id: z.string(),
    messageType: z.literal('emoticon'), // 'emoticon' 문자열 상수로 고정
    emoticonId: z.string(),
});

// ChatMessage 유니온 타입에 상응하는 Zod 유니온 스키마 생성
const ChatMessageSchema = z.union([
    ImageChatMessageSchema,
    PlainTextChatMessageSchema,
    EmoticonChatMessageSchema
]);

// 서버 요청 바디를 처리하는 예시 (Express.js 환경을 가정)
// 실제 서버 코드는 더 복잡할 수 있습니다.
function handleIncomingMessage(requestBody: any) {
    try {
        // 밸리데이션 실행: 들어온 requestBody가 ChatMessageSchema에 맞는지 검증
        // .parse() 메서드는 유효성 검사를 통과하면 파싱된 데이터를 반환, 실패하면 에러를 던짐
        const validatedMessage = ChatMessageSchema.parse(requestBody);

        // 밸리데이션 통과 후: validatedMessage는 이제 '안전한 타입'
        // TypeScript는 이 시점에서 validatedMessage의 타입을 ChatMessage (유니온 타입)으로 정확히 추론
        console.log('유효한 메시지가 수신되었습니다:', validatedMessage);
        console.log('메시지 타입:', validatedMessage.messageType);

        // 이제 비즈니스 로직에 안전하게 validatedMessage를 사용할 수 있음
        sendMessageNotification(validatedMessage); // 위에서 정의한 함수 사용

        return { status: 200, message: '메시지 처리 성공' };

    } catch (error) {
        // 유효성 검사 실패 시 (ZodError 발생)
        if (error instanceof z.ZodError) {
            console.error('유효하지 않은 메시지 형식:', error.errors);
            // 클라이언트에게 400 Bad Request 응답
            return { status: 400, message: '유효하지 않은 메시지 형식', details: error.errors };
        }
        console.error('예상치 못한 오류:', error);
        return { status: 500, message: '서버 내부 오류' };
    }
}

// 예시 사용:
// 🟢 유효한 요청 (이미지 메시지)
console.log(handleIncomingMessage({
    id: 'req-img-001',
    messageType: 'image',
    imageUrl: 'https://example.com/user_upload_image.jpg',
}));

// ❌ 유효하지 않은 요청 (messageType이 'text'인데 imageUrl이 없음)
console.log(handleIncomingMessage({
    id: 'req-err-001',
    messageType: 'plainText',
    imageUrl: 'invalid', // plainText여야 하는데 imageUrl이 있고, 심지어 string이 아님
}));

// ❌ 유효하지 않은 요청 (messageType이 'image'인데 imageUrl이 빠짐)
console.log(handleIncomingMessage({
    id: 'req-err-002',
    messageType: 'image',
    // imageUrl 필드가 없음 (Zod 스키마에 따르면 필수)
}));
```



<br/>
<br/>
<br/>

## **왜 타입세이프에 신경 써야 할까?**

이처럼 타입세이프한 코드를 작성하는 것은 개발에 있어 **실용성을 높여줍니다**. 버그를 런타임 이전에 잡아내고, 코드의 의도를 명확하게 하며, 새로운 기능을 추가하거나 기존 코드를 수정할 때 예측 가능성을 높여주기 때문입니다.

당근마켓과 같은 회사에서는 이러한 타입세이프한 스키마를 비즈니스 스펙에 맞춰 잘 만드는 것에 큰 관심을 가지고 있으며, 심지어 **스키마 레지스트리를 전사적으로 관리하는 프로젝트**까지 진행할 정도로 매우 중요하게 생각하고 있습니다. 이는 타입세이프가 단순히 개발자의 코딩 스타일을 넘어, 프로덕트의 안정성과 팀의 생산성에 직결되는 중요한 요소임을 보여줍니다.

결론적으로, 타입세이프는 단순히 오류를 피하는 것을 넘어, **우리가 설계한 시스템이 실제 세상의 비즈니스 규칙과 완벽하게 일치하도록 보장하는 강력한 도구**입니다. 마치 건축가가 설계도, 건축 과정, 그리고 최종 건물의 모든 부분이 오차 없이 일치하는지 꼼꼼히 확인하여 견고하고 안전한 건물을 짓는 과정과 같습니다. 타입세이프는 우리의 코드를 이러한 견고한 건물로 만들어주는 핵심적인 기둥이라고 할 수 있습니다.


> ### References
> - https://www.youtube.com/watch?v=wuZze0pRCD8
> - https://toss.tech/article/ts-pattern-usage
> - https://velog.io/@lky5697/11-tips-that-help-you-become-a-better-typescript-programmer