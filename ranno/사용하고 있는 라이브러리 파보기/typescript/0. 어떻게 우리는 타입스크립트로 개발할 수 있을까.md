# 어떻게 우리는 타입스크립트로 개발할 수 있을까?

타입스크립트는 자바스크립트의 Super Set이다. (A언어가 B언어의 모든 문법을 그대로 포함하고 그 위에 새로운 기능이 추가되었다면, A는 B의 SuperSet 이라고 부른다.) Dart, CoffeeScript도 JS로 트랜스파일 되지만, JS의 문법자체를 그대로 수용하지 않고 그들만의 문법이 있기 때문에 수퍼셋이라고 할 수 없다. 반면 타입스크립트는 트랜스파일하면 자바스크립트가 된다.

> **컴파일 vs 트랜스파일**
> 컴파일은 고수준 언어에서 저수준 언어로 변환하는 것 (C를 컴파일하면 바이트코드가 된다.)
> 트랜스파일은 고수준 언어에서 다른 고수준 언어로 변환하는 것 (Dart를 트랜스파일하면 JS가 되고, TS를 트랜스파일하면 JS가 된다)

<br/>

### 왜 타입스크립트는 자바스크립트의 수퍼셋으로 등장했을까?

2010년대 초반, 자바스크립트는 프론트엔드뿐만 아니라 **Node.js**의 등장으로 백엔드까지 영역을 넓히며 **대규모 애플리케이션 개발**에 사용되기 시작했다. 하지만 자바스크립트는 **동적 타입 언어**로, 변수나 함수의 타입이 **실행 중(runtime)에야 확인**되기 때문에, 규모가 커질수록 **유지보수와 협업이 어려워졌다**. 또 IDE에서 타입 안정성에 대한 지원을 받을 수 없었다.

이런 문제를 해결하고자 **Dart**, **CoffeeScript**와 같은 새로운 언어들이 등장했지만, 이들은 자바스크립트로 트랜스파일되긴 해도 **문법 자체가 달라 기존 JS 코드와 호환되지 않는다는 한계**가 있었다. 새로운 언어를 도입하려면 기존 코드를 모두 마이그레이션해야 했고, 생태계와의 단절도 피할 수 없었다.

이러한 현실 속에서, **C#과 .NET의 창시자 Anders Hejlsberg**는 마이크로소프트에서 **자바스크립트를 대체하지 않고 확장하는 방식**을 제안한다. 기존 JS 문법을 그대로 유지하면서, 타입 시스템과 정적 분석 기능을 덧붙이는 방식이다. 그렇게 등장한 언어가 바로 **TypeScript**다.

타입스크립트는 자바스크립트의 모든 문법을 포함하면서 그 위에 타입 시스템과 개발자 도구 친화적인 기능들을 추가한 **"자바스크립트의 수퍼셋(Superset)"**으로 설계되었다. 기존 JS 코드를 `.ts` 확장자로 저장해도 유효한 코드가 되기 때문에, **기존 프로젝트를 점진적으로 TypeScript로 전환할 수 있는 유연성**을 제공했다. 이러한 **“점진적 마이그레이션”** 전략은 대규모 프로젝트나 레거시 시스템에서도 부담 없이 도입할 수 있도록 만들어주었고, React, Angular, Vue 등 주요 프레임워크와도 긴밀하게 통합되며 빠르게 표준으로 자리 잡게 되었다.

<br/>

### 라이브러리에 불과한 TypeScript인데, 어떻게 우리는 `.ts` 파일을 만들 수 있을까?

우리는 `pnpm add -D typescript`로 타입스크립트를 설치한다. TypeScript는 엄밀히 말해 하나의 npm 라이브러리일 뿐, 자체 실행 환경이 있는 언어는 아니다. 그런데도 VSCode와 같은 코드 에디터에서 `.ts` 파일을 작성하고, 자동완성이나 타입 검사 같은 편리한 기능을 사용할 수 있는 이유는 무엇일까?

그 배경에는 Microsoft의 개발 역사와 도구 생태계가 깊게 연관되어 있다.  
TypeScript는 2012년에 Microsoft에서 Anders Hejlsberg 주도 하에 개발되었고, 처음에는 **Visual Studio**에서 사용하도록 설계되었다. 당시 Visual Studio에서는 플러그인을 설치하면 TypeScript 파일에 대한 타입 검사, 자동완성, 빌드 지원을 제공해, 개발자가 안전하게 코드를 작성할 수 있도록 도왔다.  
TypeScript는 초창기부터 Microsoft의 강력한 IDE 환경인 Visual Studio와 긴밀히 통합되어 있었고, 이를 통해 개발자들이 쉽게 도입할 수 있었다.

그리고 2015년 Microsoft가 오픈소스이자 크로스 플랫폼인 **Visual Studio Code (VSCode)**를 출시하면서 상황이 더욱 발전했다.  
VSCode는 내부에 TypeScript 언어 서버(Language Server)를 포함하고 있어, `.ts` 파일을 열면 자동으로 타입 검사, 오류 표시, 자동완성 등의 기능을 제공한다.  
덕분에 우리는 라이브러리에 불과한 TypeScript임에도 `.ts` 파일을 만들어 코드를 작성하고, 실시간으로 도움을 받을 수 있게 된 것이다.

<br/>

### tsc는 어떻게 js를 만들어낼까? 

타입스크립트 컴파일러 tsc (트랜스파일인데 왜 컴파일러로 부를까?) 
타입스크립트는 자바스크립트로 변환되어야 실행된다. 

어떻게 js를 만들어낼까? 

코드를 작성할 때 어떻게 타입검사를 하고 에러를 뱉을 수 있을까? 
vscode에 내장된 친구가 타입검사를 하고 에러를 뱉는걸까? 

-----


### tsc는 어떻게 자바스크립트를 만들어낼까? (진행중)

https://www.youtube.com/watch?v=X8k_4tZ16qU



TypeScript는 브라우저에서 바로 실행되지 않는다. 실제로는 `.ts`로 작성한 코드를 **자바스크립트(JS)**로 변환한 뒤 그 결과물로 실행해야 한다. 이때 변환을 수행하는 도구가 바로 **타입스크립트 컴파일러(`tsc`)**이다.

> 참고: 엄밀히 말하면 이 과정은 **트랜스파일(transpile)**에 가깝지만, 전통적인 컴파일러처럼 동작하기 때문에 **TypeScript에서는 ‘컴파일러’**라는 용어를 그대로 사용한다.

그렇다면 `tsc` 명령어를 실행했을 때 내부적으로 어떤 일이 벌어질까?  
타입스크립트 컴파일러는 다음과 같은 단계로 `.ts` 파일을 `.js` 파일로 바꾼다.
 

#### 1. tsconfig.json 읽기
`tsc`는 우선 프로젝트 루트의 **`tsconfig.json`** 파일을 찾아 읽는다. 없으면 기본 옵션으로 동작하며, 하나의 `.ts` 파일만 컴파일하는 경우 굳이 없어도 된다.
 
#### 2. 전처리 (Preprocessing)
진입점(`main.ts` 등)에서 시작하여 `import`, `export`, `/// <reference>` 등을 따라 **모든 관련 파일을 수집**한다. 이 과정을 통해 전체 프로젝트의 **의존성 그래프**가 구성된다. 

> `/// <reference path="..." />` (Triple-Slash Directives)[https://www.typescriptlang.org/docs/handbook/triple-slash-directives.html]
> - 
 
#### 3. 토큰화(Tokenization) & 파싱(Parsing)
수집된 `.ts` 파일을 문법적으로 해석하기 위해 먼저 **토큰(token)** 단위로 나누고, 이를 **구문 트리(Syntax Tree)** 또는 **추상 구문 트리(AST)**로 변환한다.

> 💡 **AST(Abstract Syntax Tree)**란?  
> 코드의 구조를 나무 형태로 표현한 자료 구조다.  
> 변수 선언, 함수 호출 등 의미 있는 단위만 추려낸 **논리적 구조**로, 타입 검사와 코드 변환 등에 사용된다.
> 예를 들어, `const a = 1 + 2;` 이 코드는 다음과 같은 AST 구조로 변환된다 (간소화된 형태)
> ```
> VariableStatement
> └── VariableDeclarationList
>    └── VariableDeclaration
>        ├── Identifier (name: a)
>        └── BinaryExpression
>            ├── NumericLiteral (1)
>            ├── PlusToken (+)
>            └── NumericLiteral (2)
> ```


> **Syntax Tree vs AST(Abstract Syntax Tree, 추상구문트리)**
>

#### 4.바인딩(Binding)


> References 
> - https://www.typescriptlang.org/docs/
> - https://yceffort.kr/2022/05/how-typescript-compiler-works
