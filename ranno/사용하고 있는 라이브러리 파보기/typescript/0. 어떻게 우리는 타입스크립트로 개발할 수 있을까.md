# 어떻게 우리는 타입스크립트로 개발할 수 있을까?

타입스크립트는 자바스크립트의 Super Set이다. (A언어가 B언어의 모든 문법을 그대로 포함하고 그 위에 새로운 기능이 추가되었다면, A는 B의 SuperSet 이라고 부른다.) Dart, CoffeeScript도 JS로 트랜스파일 되지만, JS의 문법자체를 그대로 수용하지 않고 그들만의 문법이 있기 때문에 수퍼셋이라고 할 수 없다. 반면 타입스크립트는 트랜스파일하면 자바스크립트가 된다.

> **컴파일 vs 트랜스파일**
> 컴파일은 고수준 언어에서 저수준 언어로 변환하는 것 (C를 컴파일하면 바이트코드가 된다.)
> 트랜스파일은 고수준 언어에서 다른 고수준 언어로 변환하는 것 (Dart를 트랜스파일하면 JS가 되고, TS를 트랜스파일하면 JS가 된다)

<br/>

### 왜 타입스크립트는 자바스크립트의 수퍼셋으로 등장했을까?

2010년대 초반, 자바스크립트는 프론트엔드뿐만 아니라 **Node.js**의 등장으로 백엔드까지 영역을 넓히며 **대규모 애플리케이션 개발**에 사용되기 시작했다. 하지만 자바스크립트는 **동적 타입 언어**로, 변수나 함수의 타입이 **실행 중(runtime)에야 확인**되기 때문에, 규모가 커질수록 **유지보수와 협업이 어려워졌다**. 또 IDE에서 타입 안정성에 대한 지원을 받을 수 없었다.

이런 문제를 해결하고자 **Dart**, **CoffeeScript**와 같은 새로운 언어들이 등장했지만, 이들은 자바스크립트로 트랜스파일되긴 해도 **문법 자체가 달라 기존 JS 코드와 호환되지 않는다는 한계**가 있었다. 새로운 언어를 도입하려면 기존 코드를 모두 마이그레이션해야 했고, 생태계와의 단절도 피할 수 없었다.

이러한 현실 속에서, **C#과 .NET의 창시자 Anders Hejlsberg**는 마이크로소프트에서 **자바스크립트를 대체하지 않고 확장하는 방식**을 제안한다. 기존 JS 문법을 그대로 유지하면서, 타입 시스템과 정적 분석 기능을 덧붙이는 방식이다. 그렇게 등장한 언어가 바로 **TypeScript**다.

타입스크립트는 자바스크립트의 모든 문법을 포함하면서 그 위에 타입 시스템과 개발자 도구 친화적인 기능들을 추가한 **"자바스크립트의 수퍼셋(Superset)"** 으로 설계되었다. 기존 JS 코드를 `.ts` 확장자로 저장해도 유효한 코드가 되기 때문에, **기존 프로젝트를 점진적으로 TypeScript로 전환할 수 있는 유연성**을 제공했다. 이러한 **“점진적 마이그레이션”** 전략은 대규모 프로젝트나 레거시 시스템에서도 부담 없이 도입할 수 있도록 만들어주었고, React, Angular, Vue 등 주요 프레임워크와도 긴밀하게 통합되며 빠르게 표준으로 자리 잡게 되었다.

<br/>

# tsc: 타입스크립트는 어떻게 자바스크립트를 만들어낼까?

TypeScript는 브라우저에서 바로 실행되지 않는다. 실제로는 `.ts`로 작성한 코드를 **자바스크립트(JS)**로 변환한 뒤 그 결과물로 실행해야 한다. 이때 변환을 수행하는 도구가 바로 **타입스크립트 컴파일러(`tsc`)** 이다.

> 참고: 엄밀히 말하면 이 과정은 **트랜스파일(transpile)**에 가깝지만, 전통적인 컴파일러처럼 동작하기 때문에 **TypeScript에서는 ‘컴파일러’**라는 용어를 그대로 사용한다.

그렇다면 `tsc` 명령어를 실행했을 때 내부적으로 어떤 일이 벌어질까?  
타입스크립트 컴파일러는 다음과 같은 단계로 `.ts` 파일을 `.js` 파일로 바꾼다.


<br/>
<br/> 
 

### 1. 소스코드 → 구문 트리 (Scanner & Parser)

첫 번째 단계는 소스 코드(텍스트)를 컴파일러가 이해할 수 있는 메모리 내 데이터 구조, 즉 구문 트리(Syntax Tree)로 변환하는 것이다. 이는 "토큰화(tokenizing)"와 "파싱(parsing)" 과정을 통해 이루어진다.

<br/>

#### 1.1 스캐너 (Scanner)
스캐너의 역할은 소스 텍스트를 왼쪽에서 오른쪽으로 읽으면서 의미 있는 작은 단위인 SyntaxToken으로 쪼개는 것이다.

`const msg = "hello";` 라는 코드에서 스캐너는 `const`를 키워드로, `msg`를 식별자로, `=`를 연산자로, `"hello"`를 문자열 리터럴로, `;`를 세미콜론으로 인식하고 각각의 토큰을 생성한다. 

스캐너는 코드를 "토큰 스트림"으로 변환하며, 단순히 텍스트의 패턴을 인식할 뿐 문맥(context)을 이해하지는 못한다. 
대신, 따옴표가 닫히지 않았거나 숫자 리터럴에 잘못된 형식이 포함된 경우와 같이, JavaScript 문법상 명백히 유효하지 않은 상황에서는 즉시 오류를 발생시킬 수 있습니다

> https://github.com/microsoft/TypeScript/blob/main/src/compiler/scanner.ts

<br/>

#### 1.2 파서 (Parser)

파서의 역할은 스캐너가 생성한 `SyntaxToken 스트림`에 **문맥**을 부여하여 `구문 트리(Syntax Tree)`를 구성한다. 

예를 들어, 파서는 const 키워드를 보고 "변수 선언(variable declaration)"이 시작될 것이라고 판단하고, 이에 맞춰 구문 트리의 구조를 설정합니다. 파서는 스캐너에게 다음 토큰을 요청하고, 그 토큰들이 현재 문맥에 맞는지 확인하며 트리를 구축해 나간다.

`const msg = "hello";`는 아래와 같은 구문트리로 만들어진다.
```json
{
  "type": "VariableDeclaration",
  "kind": "const"
  "declarations": [
    {
      "type": "VariableDeclarator",
      "id": {
        "type": "Identifier",
        "name": "msg"
      },
      "init": {
        "type": "Literal",
        "value": "hello",
        "raw": "\"hello\""
      }
    }
  ],
}
```

파서에서는 만들어진 구문 트리의 **문맥**을 통해 오류를 검출할 수 있다. 
구문 트리 상에서, private 클래스 변수가 클래스 외부에서 사용될 경우, 파서는 이것이 문법적으로 잘못된 위치에 있다고 판단하여 오류를 발생시킬 수 있다.




> https://astexplorer.net/
> https://github.com/microsoft/TypeScript/blob/main/src/compiler/parser.ts

 
<br/> 
<br/> 

### 2. 타입 검사 (Type Checking)

구문 트리가 생성되면, 다음 단계는 이 트리를 기반으로 타입 정보를 분석하고 검증하는 타입 검사 단계를 진행한다. 

#### 2.1 바인더 (Binder)
AST를 단방향으로 완전 탐색하여 타입 검사에 필요한 메타데이터를 추출한다. 

##### 2.1.1 Symbol Table 추출
Javascript에서 항상 유일성을 보장하는 Symbol 객체가 아니다. 
타입스크립트 컴파일 과정에서만 사용되는 메타데이터를 말하는 것으로, 스코프를 구분하기 위해 쓰인다.

```ts
const msg = "hello";
function welcome(){
  const msg = "hi";
  return msg;
}
```
여기서 msg는 두 번 등장하지만, 서로 다른 스코프에 있다. 바인더는 msg를 별도의 심볼로 등록하며 이를 추적하기 위한 구조를 만든다.
```
Global Scope
├─ msg (const)
├─ welcome (function)
   └─ Local Scope (welcome 함수 내부)
      └─ msg (const)
```
이 구조를 통해, 추후에 타입체커가 msg가 전역변수인지, 지역변수인지 구분할 수 있도록 돕는다.

심볼 테이블 생성, 스코프 설정, 플로우 노드 구성, 부모 노드 연결 등 수행
변수/함수 이름 충돌, 스코프 내 정의 여부 등을 바탕으로 진단 메시지를 생성함

> [https://www.typescriptlang.org/play/](https://www.typescriptlang.org/play/?#code/MYewdgzgLgBAthA5jAvDARACwKYBtcjoDcAUAGYCuYwUAluDAO56hzYAUAlAN4kwyhIsBMjRZaxPjABO2KBWlh4SUgF8gA) 
> https://github.com/microsoft/TypeScript/blob/main/src/compiler/binder.ts

<br/>

##### 2.1.2 Flow Nodes 구현

바인더는 AST를 순회할 때, 심볼테이블을 구축하면서도, 로직의 흐름을 분석해서 Flow Nodes를 만든다.
```ts
let val: string | number;

if (Math.random() > 0.5) val = "hello";
else val = 42;

val.toString();   
```
```
FlowNode_Entry
  └─ FlowNode_IfCondition: Math.random() > 0.5
       ├─ FlowNode_ThenBranch: val = "hello" (val의 타입이 string으로 좁혀짐)
       └─ FlowNode_ElseBranch: val = 42 (val의 타입이 number로 좁혀짐)
  └─ FlowNode_Join
       └─ val 타입은 string | number (합쳐짐)
```


조건 분기(if/else)에 따라 val의 타입 흐름(Flow Type) 을 추적함
각 분기점에 FlowNode를 설정해서 타입 체커가 나중에 이 흐름을 따라 타입 추론을 하게 된다.

> [https://www.typescriptlang.org/play](https://www.typescriptlang.org/play/?#code/DYUwLgBAbghsBcEDOYBOBLAdgcwgHwkwFcBbAIxFQG4AoG9AMwgAoBZGMACwDpUZMAJgHsSzAJQQAfBAAM3AKwSA3jQjQ4EALwQARJxDBgQnbQC+EA0hAQVa2MC0QALACYzde9zBCAymizY4lRqQA)
> https://github.com/microsoft/TypeScript/blob/main/src/compiler/binder.ts


<br/>


#### 2.2 타입 체커 (Type Checker) ----- 진행중
 
AST와 심볼 테이블을 바탕으로, 구조적 타이핑(Structural Typing) 시스템 기반 타입 검사를 수행
 


### 3. 코드생성 

#### 3.1 Emiiter 

#### 3.2 Transformer 


<br/>

# tsserver: 라이브러리에 불과한 TypeScript인데, 우리는 어떻게 vscode에서 `.ts` 파일을 만들 수 있을까? 

우리는 `pnpm add -D typescript`로 타입스크립트를 설치한다. TypeScript는 엄밀히 말해 하나의 npm 라이브러리일 뿐, 자체 실행 환경이 있는 언어는 아니다. 그런데도 VSCode와 같은 코드 에디터에서 `.ts` 파일을 작성하고, 자동완성이나 타입 검사 같은 편리한 기능을 사용할 수 있는 이유는 무엇일까?

그 배경에는 Microsoft의 개발 역사와 도구 생태계가 깊게 연관되어 있다.  
TypeScript는 2012년에 Microsoft에서 Anders Hejlsberg 주도 하에 개발되었고, 처음에는 **Visual Studio**에서 사용하도록 설계되었다. 당시 Visual Studio에서는 플러그인을 설치하면 TypeScript 파일에 대한 타입 검사, 자동완성, 빌드 지원을 제공해, 개발자가 안전하게 코드를 작성할 수 있도록 도왔다. TypeScript는 초창기부터 Microsoft의 강력한 IDE 환경인 Visual Studio와 긴밀히 통합되어 있었고, 이를 통해 개발자들이 쉽게 도입할 수 있었다.

그리고 2015년 Microsoft가 **Visual Studio Code (VSCode)** 를 출시하면서 상황이 더욱 발전했다.

<br/>

### tsserver

VSCode는 [익스텐션 형태로 타입스크립트를 지원하고 있는데](https://github.com/microsoft/vscode/tree/main/extensions/typescript-language-features), VSCode에서는 tsc를 포함하지 않고 있기 때문에, typescript를 global로 설치하거나 각 파일에서 tsc를 구동해줘야만 컴파일이 가능하다.  
> Visual Studio Code includes TypeScript language support but does not include the TypeScript compiler, tsc. You will need to install the TypeScript compiler either globally or in your workspace to transpile TypeScript source code to JavaScript (tsc HelloWorld.ts).

<br/>

그러나 내부(백그라운드)에서 `tsserver`를 구동하여, 실시간으로 타입 검사, 자동완성 등을 수행하여 유저에게 피드백을 준다.
타입스크립트 [레포지토리 위키](https://github.com/microsoft/TypeScript/wiki/Standalone-Server-%28tsserver%29)에는 tsserver를 이렇게 설명한다. `tsserver`는 혼자서 구동될 수 있는 서버이며, 타입스크립트 컴파일러와 language server를 수행하여 JSON으로 그 결과를 응답해주는 standalone 서버이며, IDE와 소통하는 역할을 한다. 
> The TypeScript standalone server (aka tsserver) is a node executable that encapsulates the TypeScript compiler and language services, and exposes them through a JSON protocol. tsserver is well suited for editors and IDE support.

<br/>
 
정확히 tsserver가 vscode에서 어떻게 동작하는지 공식문서는 없었다. 여러 블로그와 [vscode/extensions
/typescript-language-features](https://github.com/microsoft/vscode/tree/main/extensions/typescript-language-features) 레포지토리를 종합해본 결과, VSCode에서 tsserver 실행 순서는 다음과 같다. 
  

1. ts, tsx 파일을 열면, tsserver가 child process로 분기되어 백그라운드에서 초기화된다.
   - Here is an example request to open a file c:/DefinitelyTyped/gregorian-calendar/index.d.ts
   - The built-in extension spawns the node instance that loads tsserver via the call to electron.fork() in `extensions/typescript/src/typescriptServiceClient.ts`. ([링크](https://github.com/microsoft/TypeScript/wiki/Debugging-Language-Service-in-VS-Code))
2. tsserver는 프로젝트 내의 tsconfig를 읽거나 없다면 내장된 config로 타입스크립트를 설정한다.
3. vscode에서는 stdin, stdout 이벤트가 발생하면 JSON 형태로 tsserver에게 전송한다.
   - `{"seq":1,"type":"request","command":"open","arguments":{"file":"c:/DefinitelyTyped/gregorian-calendar/index.d.ts"}}` 형태로 메세지를 보낸다.
`
4. tsserver는 타입검사 등을 수행하여 vscode에게 JSON형태로 응답한다.
   - `{"seq":0,"type":"event","event":"semanticDiag","body":{"file":"c:/DefinitelyTyped/gregorian-calendar/index.d.ts","diagnostics":[{"start":{"line":264,"offset":44},"end":{"line":264,"offset":50},"text":"Binding element 'Object' implicitly has an 'any' type."}]}}
`
5. VSCode는 그 응답을 받고 ui로 보여준다.


백그라운드에서 돌아가는 tsServer 덕분에 VSCode에서는 `.ts` 파일을 열면 자동으로 타입 검사, 오류 표시, 자동완성 등의 기능을 제공한다. 덕분에 우리는 라이브러리에 불과한 TypeScript임에도 `.ts` 파일을 만들어 코드를 작성하고, 실시간으로 도움을 받을 수 있게 된 것이다.

<br/>
<br/>
<br/>

> References 
> - https://www.typescriptlang.org/docs/
> - https://code.visualstudio.com/docs/languages/typescript
> - https://github.com/microsoft/TypeScript/wiki/Standalone-Server-%28tsserver%29
> - https://github.com/microsoft/TypeScript/wiki/Debugging-Language-Service-in-VS-Code
> - https://yceffort.kr/2022/05/how-typescript-compiler-works
> - https://www.youtube.com/watch?v=X8k_4tZ16qU
