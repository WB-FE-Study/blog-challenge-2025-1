# 쉽게 유저 이벤트 관리하기 

> 데이터 소비자와 개발자 모두를 위한 이벤트 로깅 구조 개선기

초기에는 유저의 세세한 행동을 기록하는 방식으로 이벤트 로깅을 잘 정리해 왔습니다. 하지만 서비스가 성장하고 신규 PO 등 팀이 커지면서, 기존의 로깅 방식은 점점 불편한 구조로 느껴지기 시작했습니다.
- 어떤 이벤트가 어떤 페이지의 어떤 행동을 의미하는지 파악하기 어려웠고
- 새로 들어온 동료는 결국 개발자에게 하나하나 물어보아야 했으며
- 개발자 입장에서도 이벤트를 정의하고 수정하는 일이 점점 부담으로 다가왔습니다

이 문서는, 이러한 복잡하고 불편한 이벤트 구조를 보다 직관적으로 개선해나간 과정을 기록한 것입니다.

<br />
<br />
<br />

## 1. 문제 정의
 
 
### 1-1. 이벤트 정의 방식에 의한 불편함 

우리는 유저 행동을 추적하기 위해 다양한 이벤트 로깅을 쌓아 왔습니다.
예: Click Product Purchase Button, Click Payment, Click Open Alarm 등 행동 단위별로 이벤트 이름을 세부적으로 정의했습니다.이러한 방식은 당시에는 유용했지만, 서비스 규모가 커지고 새로운 PO나 데이터 분석가들이 들어오면서 예상치 못한 불편함이 나타나기 시작했습니다.

가장 큰 문제는 **이벤트를 소비하는 입장에서의 불편함**이었습니다.
이벤트 이름은 마치 변수명처럼 다루어졌고, 이벤트 하나하나가 어떤 맥락에서 발생한 것인지 파악하기가 어려웠습니다. 신규 PO는 특정 이벤트가 어떤 행동을 의미하는지, 어떤 페이지에서 발생하는지를 알기 위해 결국 프론트엔드 개발자에게 직접 문의하게 되었으며, 이 과정이 반복되면서 데이터 온보딩에 많은 리소스가 소모되었습니다.

**개발자의 입장에서도 어려움이 존재했습니다.**
우리는 모든 이벤트 정의를 하나의 TypeScript 파일에서 관리하고 있었고, 스쿼드가 늘어날수록 이 파일을 관리하기가 힘들어졌습니다.각 스쿼드에서 기능을 추가하거나 제거할 때마다 정의 파일에서 컨플릭트를 해결해야 했으며, 기능이 삭제되었을 때 이벤트 정의는 그대로 남는 경우가 많았습니다. 결과적으로 정의 파일은 점점 커지고, 불필요한 로깅 정보들이 쌓이게 되었습니다.


<br />

### 1-2. 이벤트 로깅 방식에 의한 불편함
또 다른 문제는, 이벤트 자체에 "어디서 발생했는가"에 대한 정보가 빠져 있다는 점이었습니다.

보통 리액트 컴포넌트 트리에서 “어디”는 상단에, “무엇을 했는가”는 말단에 존재합니다.
우리는 컴포넌트 트리 상단의 useEffect에서 View를 로깅하고, 말단에서 클릭 이벤트 핸들러에서 직접 호출하는 방식으로 이벤트를 남겼습니다. 이 과정은 개발자가 수동으로 정보를 넣어야 했기 때문에, Props Drilling이나 불필요한 Context 사용으로 이어졌습니다.

게다가 로깅 작업은 기능 구현 후 뒤늦게 진행되는 경우가 많아, 컴포넌트 구조를 변경해야 할 때도 있었습니다.
실수로 이벤트 속성이 누락되거나, 누락된 속성 때문에 핫픽스를 해야 하는 경우도 있었으며, 오래된 이벤트는 이미 필요한 정보가 빠져 있어 데이터를 바로 조회하지 못하는 경우도 있었습니다.

퍼널 분석에서는 View → Click 순으로 유저의 행동을 추적할 수 있었지만, 클릭 이벤트만 단독으로 분석하고자 할 때는 “무엇을 했는가”는 알 수 있어도 “어디서”는 파악하기 어려웠습니다.
 


<br />
<br />
<br />

## 2. 해결책 도출
데이터 소비자와 개발자 양쪽 모두에게 유지보수가 가능하고, 직관적인 이벤트 설계 구조가 필요하다고 판단했습니다.


<br />

### 2-1. **이벤트 정의를 단순화**  
기존처럼 행동 단위마다 세부적으로 이름을 붙이는 대신, 이벤트 타입 자체는 고정된 몇 가지로 제한하고, 세부 정보는 속성으로 분리해 전달하는 구조를 설계하였습니다.

예를 들어 Identify, View Page, View Popup, View Location, Click 등 고정된 이벤트 타입만 유지하고, UI에서 보이는 정보(textContent 등)는 속성 값으로 전달합니다.

이전에는 아래처럼 이벤트를 정의했다면:
`ClickProductPurchaseButton`

이제는 아래처럼 단순한 구조로 정의합니다:
```json
{
  "event": "Click",
  "properties": {
    "text": "상품 구매",
    "page": "/product",
    "component": "ProductDetail"
  }
}
```

이 방식은 이벤트 정의 파일이 필요 없고, 데이터 소비자가 이벤트 이름을 유추할 필요도 줄어듭니다.
텍스트만으로도 검색과 필터링이 가능하며, 정의 변경이나 추가 시 발생하던 충돌도 자연스럽게 사라지게 됩니다.

<br />

### 2-2. 컴포넌트 구조를 바꾸지 않고도 "어디서" 발생한 이벤트인지 추적할 수 있는 구조

핵심은 **“누가 > 어디서 > 어떤 행동을 했는가”**를 하나의 이벤트로 전달하는 구조였습니다.

이를 위해 유저의 흐름에 따라 이벤트 스택을 쌓는 방식으로 로깅 구조를 변경했습니다.
- 앱에 진입하면 Identify 이벤트가 발생하고
- 페이지 전환 시 View Page
- 팝업이 열리면 View Popup
- 이후 클릭 이벤트에는 위에서 발생한 정보들이 함께 전달되도록 하였습니다

이 구조를 React에서 구현하기 위해서는 `이벤트 딜리게이션` 방식에 한계가 있었는데,
Portal 구조에서는 이벤트 버블링이 불가능했기 때문입니다.

그래서 React의 Context API를 활용해 상위 페이지나 팝업의 정보를 저장하고,
하위 컴포넌트에서 클릭 이벤트가 발생할 때 해당 정보를 끌어와 함께 로깅하는 방식으로 구현하고자 했습니다.

<br />

 

### 2-3. 이 문제를 먼저 고민한 팀들은 어떻게 했을까?

비슷한 문제를 먼저 고민한 팀들도 존재했다.
가장 인상 깊었던 사례는 **토스(Toss)**와 **쿼타랩(Quotab)**이었다.

토스는 이벤트 로깅의 복잡성을 줄이기 위해 View, Click, Submit과 같은 제한된 이벤트 타입만 사용합니다.
여기에 UI 텍스트, 화면 정보 등을 속성으로 함께 전달하는 방식을 사용합니다.
또한 React Context와 유사한 구조로 공통 정보를 어디서든 참조할 수 있도록 구성하여
정의는 간결하고 해석은 명확한 구조를 구현하였습니다.

쿼타랩은 이벤트 속성(property)을 매우 적극적으로 활용합니다.
역시 단순한 이벤트 타입(View, Click, Submit)만을 사용하고,
그 외 필요한 정보들은 속성으로 세분화해 기록합니다.
이 방식 덕분에 이벤트 이름을 기억하지 않아도, 텍스트만으로 필터링 및 분석이 가능해졌습니다.
데이터 온보딩 과정도 훨씬 쉬워졌다고 합니다.

이처럼 두 팀 모두 데이터 소비자가 읽기 쉬운 이벤트 구조를 지향했으며,
우리 팀 역시 유사한 방향에서 의미 있는 시도를 하고 있다고 생각합니다.


<br/>
<br/>
<br/>

## 3. 해결(to-be) 다음주에 더 자세히

### 3-1. 이벤트 정의 단순화

### 3-2. Event Stack Context 구현

### 3-2. 선언적으로 로깅하기

로깅을 선언적으로 처리하는 방식은 **코드 작성의 간결함**, **관심사의 분리**, 그리고 **유지보수의 용이성**을 크게 향상시킬 수 있습니다. 컴포넌트를 선언적으로 로깅할 수 있게 만들면 다음과 같은 이점이 있습니다.


```tsx
const PaymentCTA = (props) => {
    return (
        <TrackClick eventId="payment-click" paymentDetails={props.paymentDetails}>
            <button>Pay Now</button>
        </TrackClick>
    )
}
```
위와 같이 TrackClick 컴포넌트를 추상화해두면, 로깅 로직을 비즈니스 로직에서 분리할 수 있습니다. 로깅의 변경이 비즈니스 로직에 영향을 주지 않고, 반대로 비즈니스 요구 변경도 로깅 구현에 영향을 주지 않기 때문에, 두 관심사가 서로 독립적으로 동작할 수 있습니다.
 

```tsx
const PaymentPage = (props) => {
    return (
        <TrackView eventId="결제페이지" 변수={props.변수}>
            <main>
                <SomeComponent />
                <PaymentCTA />
            </main>
        </TrackView>
    )
}
```
또한 위처럼 페이지 레벨에서 TrackView, 버튼 레벨에서 TrackClick을 선언적으로 감싸면, 개발자가 click 이벤트 발생 시 어떤 view에 있었는지 직접 코드를 통해 추적하거나 상태를 전달할 필요 없이, 이벤트 스택이나 컨텍스트를 활용해 자동으로 view 정보와 함께 로깅이 이뤄질 수 있습니다. 이는 반복적인 로깅 패턴을 줄이고, 로깅 관련 실수를 예방하며, 개발자의 생산성을 높여줍니다.

다만 이런 선언적 로깅이 잘 작동하려면 몇 가지 전제 조건이 필요합니다. 예를 들어, 로깅의 대상이 되는 컴포넌트가 **단일 책임 원칙(SRP)**을 지켜야 하며, 클릭 이벤트가 단순해야 합니다.
```ts
const handleClick = () => {
  switch (actionType) {
    case 'A': doA(); break;
    case 'B': doB(); break;
  }
}
```
하지만, 이렇게 사용하기 위해서는 로깅하는 대상 컴포넌트가 단일책임 원칙을 따라야만 합니다.
만약 handleClick에서 switch문으로 다른 동작을 하는 경우에는 이렇게 선언적으로 사용할 수는 없습니다.




<br/>
<br/>
<br/>

> ### 레퍼런스
> - [프론트엔드 로깅 신경 안쓰기 | 토스](https://toss.tech/article/engineering-note-5)
> - [유저 행동 이벤트 추적하기 | 쿼타랩](https://www.quotalab.com/news/user-event-logs-1)


